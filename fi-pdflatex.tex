%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  twoside, %% This option enables double-sided typesetting. Use at
           %% least 120 g/m² paper to prevent show-through. Replace
           %% with `oneside` to use one-sided typesetting; use only
           %% if you don’t have access to a double-sided printer,
           %% or if one-sided typesetting is a formal requirement
           %% at your faculty.
  table,   %% This option causes the coloring of tables. Replace
           %% with `notable` to restore plain LaTeX tables.
  lof,     %% This option prints the List of Figures. Replace with
           %% `nolof` to hide the List of Figures.
  lot,     %% This option prints the List of Tables. Replace with
           %% `nolot` to hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
  color,
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
%\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, slovak, czech%german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Juraj S\'{i}\v{c},
    gender        = m,
    advisor       = Jan Strej\v{c}ek,
    title         = {Solving DQBF using BDDs},
    TeXtitle      = {Solving DQBF using BDDs},
    keywords      = {DQBF, BDD, solver},
    TeXkeywords   = {DQBF, BDD, solver},
    abstract      = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks        = {%
      These are the acknowledgements for my thesis, which can

      span multiple paragraphs.
    },
    bib           = bibliography.bib
    %% Uncomment the following line (by removing the % symbol at
    %% the beginning) and replace `assignment.pdf` with the
    %% filename of your scanned thesis assignment.
    % assignment    = assignment.pdf,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
%% The following code fixes the rendering of BibLaTeX ISO 690
%% references in old TeX Live (such as the one at Overleaf).
\thesisload
\makeatletter
\def\thesis@biblatexiso@fix@package{iso-numeric.bbx}
\def\thesis@biblatexiso@fix@end{\relax}
\newif\ifthesis@biblatexiso@fix@
\thesis@biblatexiso@fix@false
\def\thesis@biblatexiso@fix@next#1,{%
  \def\thesis@biblatexiso@fix@current{#1}%
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@package
    \thesis@biblatexiso@fix@true
  \fi
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@end
    \expandafter
    \@gobble
  \fi
  \thesis@biblatexiso@fix@next
}
\expandafter\expandafter\expandafter\thesis@biblatexiso@fix@next\@filelist,\relax,
\ifthesis@biblatexiso@fix@
  \defbibenvironment{bibliography}
    {\list%
       {\MethodFormat}%
       {\setlength{\labelwidth}{\labelnumberwidth}%
        \setlength{\leftmargin}{\labelwidth}%
        \setlength{\labelsep}{\biblabelsep}%
        \addtolength{\leftmargin}{\labelsep}%
        \setlength{\itemsep}{\bibitemsep}%
        \setlength{\parsep}{\bibparsep}}%
        \renewcommand*{\makelabel}[1]{\hss##1}
        }%
    {\endlist}%
  {\item}%
\fi
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% The packages I use, my definitions, etc. %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for writing nice pseudocode...
\usepackage{algpseudocode}
% ...and a float wrapper for them
\usepackage{algorithm}

\usepackage{mathtools}

% for \set{}
%\usepackage{braket}
%\newcommand{\oldset}[1]{\set{#1}}
%\renewcommand{set}[1]{}
\newcommand{\set}[1]{\{{#1}\}}

% for semantic symbols [[ and ]]
\usepackage{stmaryrd}

% for nicer looking substitutions in formulas
\usepackage{nicefrac}

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
\newtheorem{lemma}[theorem]{Lemma}         %% The numbering of lemmas
\newtheorem{corollary}[theorem]{Corollary} %% and corollaries will
                               %% share the counter with theorems.
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

% [[ #1 ]]
\newcommand{\seman}[1]{\left\llbracket {#1} \right\rrbracket}
% substitution for formulas: [phi'/phi] - \substitute{phi}{phi'}
\newcommand{\substitute}[2]{\left[ \nicefrac{#2}{#1} \right]}
% the set of all boolean formulas over #1
\newcommand{\BF}[1]{BF(#1)}
% the set of all dependency quantified boolean formulas over #1
\newcommand{\DQBF}[1]{DQBF(#1)}
% the set of all valuations over #1
\newcommand{\valtns}[1]{\mathbf{A}_V}
% the set of all Boolean functions over #1
\newcommand{\BFuncs}[1]{\mathbb{F}_V}

%\renewcommand{\phi}{\varphi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\chapter{Theory}
popisat co je DQBF (ist od BF->QBF->DQBF?), neviem ci pridavat aj nonprenex, popisat BDDs, popisat ze co je nasim problemom

In this chapter we give needed ... theory for our problem... definition of dependency quantified Boolean formulas??? and BDDs?? citacie odkial vychadzam??

\section{Boolean Formulas}
In this section we will define dependency quantified Boolean formulas building up from Boolean formulas and adding quantifications followed by adding dependencies for these quantifications.


%definicia boolean formula (rekurzivna)

We first start with defining Boolean formulas. For these we need a set of variables $V = \set{x_1, \dots, x_n}$ for which we can define a valuation function $v\colon V \mapsto \{0,1\}$ that says whether each variable is true or false. Now we can define Boolean formulas as variables connected using logical operatives \emph{and} (${\land}$), \emph{or} (${\lor}$) and \emph{negation} (${\neg}$).

\begin{definition}
Let $V = \set{x_1, \dots, x_n}$ be a set of variables. \emph{Boolean formula} (BF) over $V$ has one of these forms
\begin{itemize}
    \item $x_i$, where $x_i \in V$,
    \item $\phi_1 \land \phi_2$, where $\phi_1$ and $\phi_2$ are both Boolean formulas,
    \item $\phi_1 \lor \phi_2$, where $\phi_1$ and $\phi_2$ are both Boolean formulas,
    \item $\neg\phi$, where $\phi$ is a Boolean formula.
\end{itemize}
\end{definition}
%definicia semantiky BF (+splnitelnost)
The set of all Boolean formulas over $V$ is denoted by $\BF{V}$. A function $v\colon V \mapsto \set{0,1}$ is called a \emph{valuation} over the set of variables $V$. A set of all valuations over $V$ is denoted by $\valtns{V}$. An \emph{evaluation} of BF $\phi \in \BF{V}$ in a valuation $v \in \valtns{V}$ (denoted $v(\phi)$) is defined as %can extend this valuation to $\BF{V}$%, $v\colon \BF{V} \mapsto \set{0,1}$ where
\begin{itemize}
    \item if $\phi = x_i$ where $x_i \in V$, then $v(\phi) = v(x_i)$,
    \item if $\phi = \neg\phi'$, then $v(\phi) = 1$ if $v(\phi') = 0$ otherwise $v(\phi) = 0$,
    \item if $\phi = \phi_1 \land \phi_2$, then $v(\phi) = 1$ if both $v(\phi_1) = 1$ and $v(\phi_2) = 1$, otherwise $v(\phi) = 0$ and
    \item if $\phi = \phi_1 \lor \phi_2$, then $v(\phi) = 1$ if either $v(\phi_1) = 1$ or $v(\phi_2) = 1$, otherwise $v(\phi) = 0$.
\end{itemize}
Each $\psi \in \BF{V}$ represents a \emph{Boolean function} $f_{\psi}\colon \valtns{V} \mapsto \set{0,1}$ over $V$ where $f(v) = v(\psi)$. The set of all Boolean functions over $V$ is denoted by $\BFuncs{V}$.
%We will abuse notation and use $v(\phi)$ for extended $v$????? 
%mozno napisat ako ze ten extend nejak oznacime (napr u_v) ale ak je to jasne tak abusneme notation a budeme pod $v(\phi)$ mysliet $u_v(\phi)$


An important notion for BFs is \emph{satisfiability}. We say that BF $\phi \in \BF{V}$ is \emph{satisfiable} if there exists valuation $v$ over $V$ in which $\phi$ is true, that is $v(\phi) = 1$. Let $\phi_1, \phi_2 \in \BF{V}$. We say that they are \emph{equivalent}, denoted $\phi_1 = \phi_2$, if for all valuations $v$ it holds that $v(\phi_1) = v(\phi_2)$. If they are either both satisfiable or they are both unsatisfiable, we call them \emph{equisatisfiable}. %Notice that equisatisfiability of two formulas is just talking about their satisfiability, which means that these formulas can be over different sets of variables.

\begin{example}
dat tu priklad nejakych formul?? a ukazat ze v akych valuaciach su splnene/nesplnene, priklad equal, equisatisfiable
\end{example}

%definovat negation normal form + cnf
\subsection{Conjuctive Normal Form}
\label{sec:BF:CNF}
To work with BFs it is usually easier to have them in some special forms. The first one we define is called conjuctive normal form.

\begin{definition}
We say that boolean formula $\phi \in \BF{V}$ is in conjuctive normal form (CNF) if there exist BFs $\psi_1,\dots,\psi_n \in \BF{V}$ where
\[\phi = \psi_1 \land \dots \land \psi_n\]
and
\[\psi_i = l_{i1} \lor \dots \lor l_{i{m_i}}\]
for each $i = 1, \dots, n$ and for each $l_{ij}$ where $j \in \set{1,\dots,m_i}$ either $l_{ij} = x$ or $l_{ij} = \neg x$ for some $x \in V$.
\end{definition}
BFs $\psi_1,\dots,\psi_n$ are called clauses and $l_{ij}$ are called literals. That is BF is in CNF if it is a conjuction of clauses which are disjuncts of literals, where literal is either a variable or negation of a variable.

\begin{example}
priklad nejakej formule co je cnf a co neni abo daco
\end{example}

For every BF $\phi$ there exists an equivalent formula in CNF which can be exponentially larger than $\phi$. However, there exists a construction that by adding some new variables results in an equisatisfiable BF $\phi_{CNF}$ which is only polynomially larger than the original BF $\phi$ (citedacotu).
%TODO explain clause, literal...

\subsection{Negation ci jak sa to vola Normal Form????}
toto asi zadefinujem pre QBF/DQBF ak vobec - alebo mozno to treba fakt tu, ked budem chciet hovorit ze HQSpre meni formulu????

\section{Quantified Boolean Formulas}

Having defined BFs, we can move to the next step on our way to defining DQBF by adding quantifiers. We add existential (${\exists}$) and universal (${\forall}$) quantifiers which will be bounded to variables. %Existential quantifier $\exists x_i$ will then tell us that at least for one of $x_i = 0$, $x_i = 1$ formula holds, while for universal quantifier $\forall x_i$ for both $x_i = 0$ and $x_i = 1$ formula holds.

we give only prenex form, because the qbfs are not that important for us????????

%definicia QBF (ak budem robit aj non-prenex DQBF tak rekurzivna + nahradzovanie, inak prenex)
\begin{definition}
Let $V = \set{x_1,\dots,x_n}$ be a set of variables and $\phi \in \BF{V}$. A \emph{quantified Boolean formula} (QBF) $\psi$ over $V$ in closed prenex form is given by
\[\psi \coloneqq Q_1 x_1 Q_2 x_2 \dots Q_n x_n \phi\]
where $Q_i \in \set{{\exists}, {\forall}}$ and $x_i \in V$ are distinct for all $i \in \set{1,2,\dots,n}$.
\end{definition}

We call the variables $x_i$ such that $Q_i = \exists$ existential variables (denoted $V_{\psi}^{\exists}$) and the variables where $Q_i = \forall$ universal variables (denoted $V_{\psi}^{\forall}$). Again, we define satisfiability for QBFs, where QBF $\psi$ from the definition is satisfiable if there exist functions $s_{x}\colon x \mapsto V_{\psi}^{\forall}$ for each $x \in V_{\psi}^{\exists}$ (called Skolem functions) such that $\phi$ where every $x \in V_{\psi}^{\exists}$ is replaced by $s_x(x)$ is evaluated to $1$ in every valuation $v\colon V_{\psi}^{\forall} \mapsto \set{0,1}$.

%definicia semantiky (+splnitelnost)
%Let $Q\BF{V}$ be the set of all quantified Boolean formulas over $V$ and $v\colon V \mapsto \set{0,1}$ a valuation over the set of variables $V$. Again, we can extend $v$ to $Q\BF{V}$ where 
%\begin{itemize}
%    \item for $\phi \in \BF{V}$, $v(\phi)$ behaves like $v$ extended to $\BF{V}$ as explained in section TODO
%    \item $v(\forall x Q_2 x_2 \dots Q_n x_n \phi) = 1$ if both $v(Q_2 x_2 \dots Q_n x_n \phi) = 1$ and ... TODO definovat nahrazdovanie + doplnit do definicie BF 1 a 0 konstanty
%\end{itemize}
%mozno pisat skor ze pre \psi z QBF, v(psi) je definovana pre tvar \psi = itemize ...
%definovat bounded
%Notice that in this definition of semantics the variables that are bounded with some quantifier do not care what they are evaluated to. That is priklad It can be seen that if addded $\exists x$ to unbounded variables $x$ to the beginning of any QBF, we would not need any valuation etcetc

%We can also define satisfiability on QBF, similarly to BF. We say that QBF $\psi$ is satisfiable if there exists valuation $v$ such that $v(\psi) = 1$.

priklad

\section{Dependency Quantified Boolean Formulas}
Quantifiers have expanded BFs quite considerably (mozno nieco ako expressibality???). However, there is still one drawback of QBFs - quantified variable $x$ depends on all variables that are quantified before $x$. The problem with this dependency relation is that it is given by how quantifiers follow each other. vysvetlit na priklade z predchadzajucej sekcie But what if we want nonlinear dependencies? And what would they even mean? This is where dependency quantified Boolean formulas (DQBFs) will shine!

DQBFs allow existential variables to be non-linearly dependent on the set of universal variables. That is the dependency set of each existential variable is explicitly given in the formula. This set is then used as a support set of the skolem function for the existential variable which allows for richer expresiability???? of DQBFs over QBFs.  

We start with the definition of DQBFs in prenex normal form on which we explain the basic notions and then we give definition of DQBFs in non-prenex negation normal form which allows quantifiers inside formulas. Following this we give theorems that show which DQBFs are equisatisfiable and can be replaced with each other which results in
\begin{itemize}
    \item pushing quantifiers inside formula,
    \item elimination of quantified variables or
    \item ????removal of universal variables from the dependency sets of existential variables.????
\end{itemize}

\subsection{Prenex Normal Form}
The first form called prenex normal form is an anallogy of the prenex normal form of QBFs.

%definicia DQBF -ak robim nonprenex tak zacat s prenex ale vysvetlit ze pre jednoduchost zacneme s tym + semantika prenex + priklady
\begin{definition}
  Let $V = \set{x_1, \dots, x_n, y_1, \dots, y_m}$ be a set of variables and $\phi \in \BF{V}$ a BF over $V$. A \emph{dependency quantified Boolean formula} (DQBF) $\psi$ in prenex normal form is given by
  \[\psi \coloneqq \forall x_1 \dots \forall x_n \exists y_1 (D_1) \dots \exists y_m (D_m) \phi\]
  where $D_i \subseteq \set{x_1, \dots, x_n}$, $i \in \set{1,\dots,m}$, is a \emph{dependency sets} of variable $y_i$.
\end{definition}
We call the BF $\phi$ the matrix of $\psi$ and .. the quantifier prefix of $\psi$. 

\begin{example}
Let use an example to explain the meaning behind dependency sets. Let 
\[\psi = \forall x_1 \forall x_2 \exists (x1) y_1 \exists (x_2) y_2 : (x_1 \land x_2) \iff (y1 \iff y2)\]
be a DQBF. Both $y_1$ and $y_2$ depend only on one variable, $x_1$ and $x_2$ respectively. TODO + citovat odkial som vzal priklad
\end{example}

\subsection{Negation Normal Form}
tu dat nonprenex ak robim, semantika + priklady + dokazy o nahradzovani a eliminovani kvantifikatorov - dat dokaz ze ked equality tak to ide nahradit (kvoli tomu ze maju rovnake hodnoty volnych premennych)

In this section we give a definition of normal form of DQBF that is non-prenex. This allows quantifiers inside the formula however, negation is only allowed in front of variables. This restriction stems from the fact that prenex DQBFs are not syntactically closed under negation (cite ten clanok)???? This form can be then used better elimination of variables???pushin quantifiers inside formula???? ido not know. This definition is from~\cite{HQSquantifierLocalization}.

\begin{definition}
  Let $V$ be the set of variables. The set $\DQBF{V}$ of \emph{DQBFs in negation normal form} over $V$ as well as their existential, universal and free variables are defined by ... The set $\DQBF{V}$ is defined to be the smallest set satisfying these rules. We set $V_{\psi} = V...$  A DQBF in negation normal form has one of these forms
  \begin{itemize}
      \item $v$, where $v \in V$
      \item $\neg v$, where $v \in V$
      \item $\exists v(D_v):$
  \end{itemize}
\end{definition}

povedat ze prenex je len nnf kde matica je prevedena do nnf (asi dat sekciu nnf pre BF)

dat definiciu semantiky


\subsection{Substitution Theorems/ Elimination Theorems/ ???}

\begin{theorem}
  Let $\phi, \psi_1, \psi_2$ be a ??non-prenex?? DQBFs where $\psi_1$ is subformula of $\phi$ and $\psi_1 = \psi_2$. Assume that for each existential variable $y \in V_{\psi_1}^{\exists}$ the dependency set of $y$ in $\psi_1$ is equal to the dependency set of $y$ in $\psi_2$. Then it holds that $\phi = \phi\substitute{\psi_1}{\psi_2}$. 
\end{theorem}
\begin{proof}
  We show that if $s \in \seman{\phi}$ then $s \in \seman{\phi\substitute{\psi_1}{\psi_2}}$ and vice versa. Notice that $V_{\phi}^{\forall} = V_{\phi\substitute{\psi_1}{\psi_2}}^{\forall}$ and $V_{\psi_1}^{\forall} = V_{\psi_2}^{\forall}$. Let $s \in \seman{\phi}$ and assume that $s \not\in \seman{\phi\substitute{\psi_1}{\psi_2}}$.  That means there exists a valuation $v\colon V_{\phi}^{\forall} \mapsto \set{0,1}$ such that $v(s(\phi)) = 1$ but $v(s(\phi\substitute{\psi_1}{\psi_2})) = 0$. Because these two formulas are the same except for the difference in $\psi_1$ and $\psi_2$ the change of evaluation has to come from the difference in evaluation of these two formulas. That is $v(s(\psi_1)) \not= v(s(\psi_2))$. If $\psi_1 = v$ for some $v \in V$, then $\psi_2 = v$ and then $v(s(\psi_1)) = v(s(\psi_2))$. This means both $\psi_1$ and $\psi_2$ are something more complex than just a variable which cannot have negation in front of it in $\phi$ (because negation can be only in front of a variable). This also means that BF $s(\phi)$ will have $s(\psi_1)$ only in sequence of conjunctions and disjunctions. But because $v(s(\phi))=1$ and $v(s(\phi\substitute{\psi_1}{\psi_2}) = 0$ where the only difference in these formulas are $s(\psi_1)$ and $s(\psi_2)$ it has to hold that $v(s(\psi_1)) = 1$ and $v(s(\psi_2)) = 0$. Let $s'$ be a restriction of $s$ on $V_{\psi_1}^{\exists} \cup V_{\psi_1}^{free}$. If $s' \in \seman{\psi_1}$ then from $\psi_1 = \psi_2$ it has to hold that $s' \in \seman{\psi_2}$ and so $v(s(\psi_2)) = 1$. This means that $s' \not\in \seman{\psi_1}$.
\end{proof}


\section{Binary Decision Diagrams}
%mozno tu dat high level def. ze BDD je tree like struktura kde nodes reprezentuju variables z ktorych vychadzaju hrany reprezentujuce valuaciu pre 0 a 1
Having defined DQBFs we can now turn our attention to their representation. We have already defined some normal forms in section blabla, but algorithmically, working with them in this form would not be very effective (why?). For this reason binary decision diagrams (BDDs) were introduced. These structures allow for a succinct representation of BFs with an effecient polynomial time implementation of logical operations.

Let $V$ be a set of variables. A binary decision diagram over $V$ is a binary tree like structure with two terminal nodes 0 and 1 and a set of non-terminal nodes each representing a variable from $V$. Each non-terminal node has two child nodes with edges connecting them labeled with 0 and 1 respectively.

%We will give a definition of reduced ordered binary decision diagram, however we do not use that name and whenever we say BDD we mean ROBDD.

Let $v\colon V \mapsto \{0,1\}$ be a valuation over $V$. BDD $B$ in this valuation is evaluated to 0 or 1 by moving along the edges of non-terminal nodes, where if we are in node representing variable $x \in V$, then we move along the edge labelled by $v(x)$. The resulting terminal node is then the evaluation of $B$ in $v$. BDD $B$ then represents a Boolean formula $\phi \in \BF{V}$ if for each valuation $v$ it holds that $B$ is evaluated to $v(\phi)$.

\begin{example}
Fig. ??? shows an example of a BDD for BF ... Edges labelled by 0 are dashed???, by 1 are full??? 
\end{example}

% chceme mat linearne operacie ---> treba aby boli usporiadane ---> shannon expansion ---> ukazat operacie???
When we have two BDDs, we want to have an effective way to compute their conjunction/disjunction. Such an algorithm should just traverse the BDDs in the same way while comparing the variables in the nodes. However, variables in the nodes on the paths from the root in general BDDs can occur in any order, which would cause problems with simple traversal of BDDs. To solve this we add an ordering on the set of variables $V$. The nodes in the BDD are then sorted based on this ordering. The resulting BDD is called an ordered binary decision diagram (OBDD).

\begin{example}
ukazat asi z previous example 2 orderings a povedat daco o tom ze operacie sa daju teraz implementovat jednoducho len prechadzanim stromom
\end{example}

%nieco o ROBDD, ze pre kazde BF existuje prave jedno unikatne pre kazde zoradenie + ze vyber zoradenia je dolezity + ze da sa dynamicky preukladat???
OBDDs still suffer from one problem -- for each BF we would like to have for given order on $V$ only one OBDD representing it. This is not the case, notice OBDDs on fig. ????? and ???. Both represents BF ??? but they are different. That is why we introduce reduced OBDDs (ROBDD) (vysvetlit lepsie ze to neni moj prinos). ROBDD is an OBDD such that all isomorphic sub-BDDs are merged and the nodes that have the same BDD as children are removed.

\begin{example}
porovnat nejake OBDD s jeho ROBDD, detailne (kde sa ukaze )
\end{example}

In the following we will use the term BDD instead of ROBDD.

\section{And-Inverter Graphs - je ich treba rozobrat???}

\chapter{State of the Art}
%problem - vytvorit algoritmus ktory zisti ze ci dana DQBF formula je splnitelna alebo nie pomocou BDDcok alebo jej podobnym strukturam (mozno dat do teorie)

%popisat tu aj nejak historiu DQBF, akoze napriklad ten clanok s henkins qunatifiers abo daco???

%Having laid out all the necessary theory we can now define the problem we are trying to solve and current implementations solving it.

%\section{The Problem of Satisfiability}
%Let $\psi$ be DQBF. The problem we are trying to solve is to tell whether this formula is satisfiable, that is if there exists model in which it is true. For BF, this problem belongs to NP-complete class of problems cite. If we move to QBF, the problem gets harder and belongs to PSPACE-complete class. As was shown in CITE, this problem for DQBF belongs in NEXPTIME-complete class of problems, that is it is even harder.

%\section{State of the Art}
%ake solvre existuju (vybrat tie s ktorymi budem porovnavat?), trocha viac popisat HQS a ze ako funguje aj HQSpre (lebo ho pouzivam) - ale fakt len zopar veci spomenut, mozno aj to ze mozme pouzit vytvaranie log. gates pretoze to menim do BDD ako to robia v HQS
In this chapter we give an overview of existing solutions and solvers which tackle the problem. An overview of existing solvers can also be found in~\cite{DQBFStateOfArtTalk,DQBFStateOfArt,DQBFStateOfArtNew} that is why we just give a short updated overview here (short for DQDPLL, iDQ, iProver and dCAQE). However we go into more details for solver HQS, because the methods we used for developing our solver are based on the workings of this solver.
%current solutions, that already exist

%nieco o tom ze vacsina funguje na CNF, ale HQS a moje bude na NNF

%fast DQBF refutation - ze premienaju na QBF abo daco (bunsat)

\section{First Solution - DQDPLL}
The first solver that tackled the satisfiability problem for DQBF was based on DPLL(TODO cite) algorithm which is successfully used for BF and QBF solvers(TODO cite??). This algorithm works on formulas in CNF by searching for a satisfying assignment based on the clauses in CNF. By recursively choosing an assignment for literals and checking whether CNF stay consistent, DPLL searches trough all assignments until a satisfying one is found or all of them are decided to be unsatisfying. An adaptation called DQDPLL~\cite{DPLLalgorithm} was introduced for DQBF which extended existing solutions for QBF by adding so-called Skolem clauses which encode the dependencies between existential and universal variables. However, by doing so the algorithm becomes too slow and results in noncompetitive solver.

\section{Instantiation -- iDQ and iProver}
The first efficient DQBF solver, called iDQ~\cite{iDQandDQDIMACS}, is based on instantiation technique used for solving Effectively Propositional Logic (EPR)~\cite{iProver}. This solver also works only on formulas in CNF where in each step of the algorithm it tries to create a BF $\phi$ that is an overapproximation of an input DQBF. This is done by instantiating some set of clauses, that is it applies universal expansion locally to them. This BF $\phi$ is then checked for satisfiability, where if $\phi$ is unsatisfiable then the input DQBF is also not satisfiable, while if it is satisfiable, it must be checked if the resulting valuation is valid for the input DQBF. If it is not, then it is used to create more clause instances which are then used to refine this overapproximation.

However, a solver for EPR can also be used directly for DQBF. Because EPR belongs to the same complexity class as DQBF, there exists a polynomial-time reduction from DQBF to EPR~\cite{iDQandDQDIMACS}. This is used by EPR solver iProver~\cite{iProver} which transforms DQBF in CNF to EPR instance and then solves this. In the SAT competition??? it turned out that iProver is more powerful compared to iDQ??

\section{Clausal Abstraction -- dCAQE}
Another DQBF solver called dCAQE~\cite{dCAQE} is based on clausal abstraction (mozno citovat). This solver\,---\,working again on DQBF in CNF\,---\,first puts universally and existentially quantified variables to some sets (called nodes) which are then divided into levels based on the ordering of dependencies of existential variables. The algorithm then construct for each node on each level a BF that represents which clauses in CNF it can satisfy (for existential node) or falsify (for universal node). The algorithm then builds a candidate valuation by processing each level. For each level either this valuation is extended, there is some conflict which means that the algorithm has to backtrack to some lower level and refine the abstraction or the candidate valuation is a satisfying one ending the algorithm.

%odkaz na sekciu o PSPACE sublassse, ze je mozne ze tento solver nie je uplny

%mozno spomenut fork splitting or some shit like that, v arXiv rozsirenej verzii maju nieco o tom v appendixe

\section{Quantifier Elimination -- HQS}
The next solver is based on quantifier elimination. This solver's basic premise is simple\,---\,it iteratively chooses some universal variable for universal expansion (theorem ???) thus eliminating it and then eliminates all existential quantifiers that are dependent on all leftover universal quantifiers using theroem???.
%nejak vysvetlit ze pouzivaju AIG

\begin{algorithm}
\caption{Quantifier elimination algorithm}
\label{alg:QE}
\begin{algorithmic}[1]
\Function{SolveDQBF}{DQBF $\psi$ in prenex form}
\While{$V_{\psi}^{\forall}$ is not empty}%there is some universal variable $x$ in $\psi$
    \State choose $x$ from $V_{\psi}^{\forall}$
    \State $\psi = \forall\text{-elimination}(x,\psi)$% universal expansion
    \ForAll{$y \in V_{\psi}^{\exists}$ s. t. $D_y = V_{\psi}^{\forall}$} %existential variables $y$ such that they depend on all universal variables in $\psi$
        \State $\psi = \exists\text{-elimination}(y,\psi)$% existential expansion
    \EndFor
\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

In~\cite{HQSsimpleAlg} the authors introduced the basic algorithm for solving DQBF in this way. (mozno spomenut ze to vlastne vymysleli aj v iDQ clanku, ako nejaky base solver ktory pouziva BDDcka) Algorithm~\ref{alg:QE} shows simple pseudocode of this. In every step this algorithm chooses using some heuristic an universal variable to eliminate. In~\cite{HQSsimpleAlg} they used a heuristic where the universal variable is chosen based on the number of existential ones that depend on it - they choose the one that has minimal number of dependencies. After that, all the existential variables that depend on everything are also eliminated. To use this algorithm it is important to choose a good representation of the matrix of the DQBF. For this the authors chose and-inverter graphs (AIG) which are a tree-like structures where non-terminal nodes represent conjunction, terminal nodes are variables and these are connected with two types of nodes: normal ones and those that represent negation. With a proper implementation of operations they can be optimised in such a way that they reuse parts of the graphs resulting in functionally reduced AIGs~\cite{FRAIGs}.
%mozno aj tu spomenut tie theorems

%MYSLIENKA K TODO - heuristika ze vyberam podla poctu zavislosti v originalnom DQBF alebo v tom co sa mi postupne po odstranovani vytvara

% bol zlepseny s tym ze pridali nejaky preprocessing, odstranovanie pure a daco vars a QBF solver ako subproceduru - dat pekny obrazok
Following this technique,  the authors of~\cite{HQSquantifierElimination} introduced solver HQS which was enhanced by using QBF solver as a subprocedure. They still eliminate quantifiers in similar fashion, but now they do it until the formula can be transformed to QBF. On this QBF they then run already existing solver for QBF called AIGSolve~\cite{AIGSolve} which can use more effective techniques developed for QBFs. Universal quantifiers to eliminate are chosen in the beginning in such a way that the number of universal eliminations is as small as possible while still the resulting formula is QBF. For this they build a dependency graph in which nodes are existential variables where $y_i$ is connected to $y_j$ if for their dependency sets hold that $D_{y_i} \not\subseteq D_{y_j}$. They noticed that if this graph is acyclic, the formula can be seen as QBF. Furthermore, there is a cycle in this graph iff there is a simple cycle in the graph (between two nodes). They use this to create an instance of MaxSAT problem which is a problem of finding a valuation of one BF while maximizing another formula. This instance then encodes which universal variables have to be eliminated so the dependency graph becomes acyclic while minimising the number of universal variables to eliminate. After finding the set of variables to eliminate, they follow with an improved quantifier elimination algorithm. They improved it by adding a preprocessing step (see section~\ref{sec:preprocessing}), syntactic detection and elimination of special types of variables called unit and pure and already mentioned subprocedure that calls QBF solver AIGSolve.

In~\cite{HQSdependencyElimination} the algorithm was changed a bit again. The authors were interested in whether it is possible to somehow remove specific dependencies from the list of dependencies of existential variable. They have shown that it is possible at the expense of adding a new existential variable. This is similar to the already shown universal expansion (theroem???), however, by removing just one dependency we add just one new existential variable. Let for example \[\psi = \forall x_1 \dots \forall x_n \exists y_1(D_{y_1}) \dots \exists y_m(D_{y_m}) \colon \phi\] be a prenex DQBF where $\psi$ is a BF and $x_1 \in D_{y_1}$. We can now remove $x_1$ from $D_{y_1}$ by adding a copy of $y_1$ resulting in an equisatisfiable DQBF
\begin{multline*}
\forall x_1 \dots \forall x_n \exists y_1^0(D_{y_1} \setminus \{x_1\}) \exists y_1^1(D_{y_1} \setminus \{x_1\}) \exists y_2(D_{y_2})\dots \exists y_m(D_{y_m}) \colon \\
\phi\left[((\neg x_1 \land y_1^0) \lor (\neg x_1 \land y_1^1))/y_1\right].
\end{multline*}
Using this the authors do not look for a set of universal variables to eliminate but for partial dependencies which removal will result in a DQBF which can be transformed into QBF. Again, they create a dependency graph which is acyclic iff DQBF can be seen as QBF. But now they create a bipartite graph whose two sets of nodes are the set of universal variables and the set of existential variables which are connected based on whether universal variable is in the dependency set of existential one. Similarly to previous, they use this graph to solve an optimization problem that encodes which dependencies to remove to get QBF which can then be solved with AIGSolve.
%This was good and all, but in~\cite{HQSdependencyElimination} they zaoberat sa whether it is possible to remove only some universal variables from dependency sets. They showed it is possible ....tu asi dat cely ten teorem ak som ho nedal do teorie...

Last but not least in~\cite{HQSquantifierLocalization} the authors have given a theoretical foundations for non-prenex DQBFs and the possibility to push and eliminate quantifiers inside formulas as explained in section ????. Using this they improve HQS by adding another step in the algorithm, where they first push quantifiers as much as possible into the formula, eliminate the existential variables using theorem ??? and then return the formula back to the prenex form. After this they start with elimination of universal quantifiers as was explained in previous paragraphs.

\section{Preprocessing}
\label{sec:preprocessing}
In previous sections we give an overview of techniques used for implementations of different solvers. This sections explains some techniques that are used before the actual solvers run, called fittingly preprocessing.


%We have just gave an overiew of different solvers for DQBF. However, 
%preprocessing pre QBF je dolezity, ergo asi je aj pre DQBF a teda je vela vyzkumu na preprocessing techniques

\subsection{HQSpre}
The first and only preprocessing engine for DQBF called HQSpre~\cite{HQSpre1,HQSpre2,HQSpreJournal} took many techniques used for QBF preprocessing and lifted them to the DQBF case. We go into details only for one technique called gate extraction. As was explained in Section~\ref{sec:BF:CNF}, transforming BF to CNF can result in polynomial increase of the size of the formula by adding new variables. Gate extraction works in opposite direction\,---\,it tries to extract this newly introduced variables and turn the formula back into one that is not in CNF. This does not mean that gate extraction works only on formulas in CNF, it can be used generally by finding ...connections????..... which makes it possible to replace a variable by some function of existing variables. However, this technique can only be used by solvers which can work on DQBFs which are not in CNF. Currently, that is only HQS. For a thorough explanation of other techniques used by HQSpre we refer the reader to~\cite{HQSpreJournal}. 

\subsection{Approximations}
Another technique which is used in some solvers as preprocessing step is to find some BF or QBF approximations which can be used with existing solvers for BFs/QBFs to potentially give us faster result about the input DQBF (satisfiability for underapproximations, unsatisfiability for overapproximations). In~\cite{HQSsimpleAlg} QBF approximations are introduced which are created by changing the dependencies of existential variables that result in QBF with the same matrix. However, these approximations can be precise only up to some level. By adding some information to these QBF overapproximation (thus changing the matrix), the authors in~\cite{FastDQBFRefutation} were able to create more and more precise QBF overapproximations. For more thorough explanation of these approximations see~\cite[Section~3]{HQSpreJournal}.

\subsection{PSPACE-complete subclass}
The last preprocessing technique is simply put just a check whether DQBF does not belong to a subclass of problems which are PSPACE-complete and if it does, it is transformed to QBF on which existing QBF solver is run. The simplest such subclass would be those DQBFs whose dependencies are linearly ordered. Then it can be easily transformed into QBF by reordering the quantifiers. In~\cite{PSPACEsubclass} the authors investigated whether there is some another DQBF subclass which is PSPACE-complete. They show that DQBFs where the dependency sets are either equal or pairwise disjoint can be transformed into QBFs with just linear increase in size. Thus having a check on whether an input DQBF belongs to this class before running a DQBF solver and if it does transforming it into QBF and running a QBF solver can improve the efficiency.

%As a note, 

%If we can find a subclass that is pspace we can translate to QBF - obviously for DQBF that is already in linear order can be seen as BQF
%QBF can be viewed as a DQBF with linearly ordered dependencies. This is enough to make it PSPACE-complete and so, in PSPACECLANOK they were interested in whether there is some another sublass of DQBF which is PSPACE-complete. They have shown that  
%existuje classa DQBFs ktore idu iba s polynomialnym zvacsenim previest na QBF ---> patri do PSPACE a je mozne to pouzit ako preprocessing step kde ak zistime ze sme v tejto classe tak pustime QBF solver dajaky
%As a note toto vzislo z toho, ze clanok zrobil dajaky system ktory je rozsirenie QBF systemu kde pridali fork extension pravidlo. They showed that this system is complete and sound for DQBF, however, in dCAQEclanok (ale v appendixe extended version) and PSPACEclanok ukazali ze to tak nie je (nie je complete ci co). Obe tieto clanky ukazali ze tento system je complete pre tuto PSPACE classu. Zaroven dCAQE vyuziva tento fork extension ???a zle si myslia ze tato classa je NEXPTIME??? vo svojom algoritme, takze je moznost ze ich algoritmus nefunguje pre celu classu DQBF


% vysvetlit prve dve clanky, ze ide o jednoducho univ. expansion -> exist. elimination pouzitim AIG a pridanim nejakych zaujimavych drobnosti sa vytvori QBF ktory sa hodi do nejakeho existujuceho solvru (pridat obrazok toho cyklu + naivny alg.), tu spomenut aj preprocessor ze je vysvetleny niekde
% potom vysvetlit ze je dolezity spravny vyber univ. kv. na expansion a vysvetlit ze v naivnom alg. to je jednoduche proste tie na ktore zavisia najviac, v tych dalsich clankoch vytvoreny dependency graf ktory sa nejak riesi, neskor sa odstranuje priamo jedna zavislost pre exist. kvantifikatory
% potom zacat hovorit o tom ze ako pchat kvantifikatory do vnutra, kde to nejak zrobili
% vysvetlit preprocessor (hlavne gate reduction alebo jak to nazvat)
% spomenut asi aj overapproximations

\chapter{Algorithm}

\section{High level defintion???}

\section{Heuristics for order of elimination of universal variables}

\chapter{Implementation}

\chapter{Experimental results}
grafygrafygrafy

\printbibliography

\chapter{Inserting the index}
After using the \verb"\makeindex" macro and loading the
\texttt{makeidx} package that provides additional indexing
commands, index entries can be created by issuing the \verb"\index"
command. \index{dummy text|(}It is possible to create ranged index
entries, which will encompass a span of text.\index{dummy text|)}
To insert complex typographic material -- such as $\alpha$
\index{alpha@$\alpha$} or \TeX{} \index{TeX@\TeX} --
into the index, you need to specify a text string, which will
determine how the entry will be sorted. It is also possible to
create hierarchal entries. \index{vehicles!trucks}
\index{vehicles!speed cars}

After typesetting the document, it is necessary to generate the
index by running
\begin{center}%
  \texttt{texindy -I latex -C utf8 -L }$\langle$\textit{locale}%
  $\rangle$\texttt{ \jobname.idx}
\end{center}
from the command line, where $\langle$\textit{locale}$\rangle$
corresponds to the main locale of your thesis -- such as
\texttt{english}, and then typesetting the document again.

The \texttt{texindy} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory. Select the \textsf{Open Command
Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- the commands are
executed automatically, although the locale may be erroneously
detected, or the \texttt{makeindex} tool (which is only able to
sort entries that contain digits and letters of the English
alphabet) may be used instead of \texttt{texindy}. In either case,
the index will be ill-sorted.

  \makeatletter\thesis@blocks@clear\makeatother
  \phantomsection %% Print the index and insert it into the
  \addcontentsline{toc}{chapter}{\indexname} %% table of contents.
  \printindex

\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  twoside, %% This option enables double-sided typesetting. Use at
           %% least 120 g/m² paper to prevent show-through. Replace
           %% with `oneside` to use one-sided typesetting; use only
           %% if you don’t have access to a double-sided printer,
           %% or if one-sided typesetting is a formal requirement
           %% at your faculty.
  table,   %% This option causes the coloring of tables. Replace
           %% with `notable` to restore plain LaTeX tables.
  nolof,     %% This option prints the List of Figures. Replace with
           %% `nolof` to hide the List of Figures.
  nolot,     %% This option prints the List of Tables. Replace with
           %% `nolot` to hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
%\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, slovak, czech%german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Juraj S\'{i}\v{c},
    gender        = m,
    advisor       = {Jan Strej\v{c}ek},%\\ \textbf{Co-advisor:} Martin Jon\'{a}\v{s}},
    title         = {Satisfiability of DQBF Using Binary Decision Diagrams},
    TeXtitle      = {Satisfiability of DQBF Using Binary Decision Diagrams},
    keywords      = {dependency quantified Boolean formula, DQBF, binary decision diagram, BDD, satisfiability, solver},
    TeXkeywords   = {dependency quantified Boolean formula, DQBF, binary decision diagram, BDD, satisfiability, solver},
    abstract      = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks        = {%
      These are the acknowledgements for my thesis, which can

      span multiple paragraphs.
    },
    bib           = bibliography.bib
    %% Uncomment the following line (by removing the % symbol at
    %% the beginning) and replace `assignment.pdf` with the
    %% filename of your scanned thesis assignment.
    % assignment    = assignment.pdf,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
%% The following code fixes the rendering of BibLaTeX ISO 690
%% references in old TeX Live (such as the one at Overleaf).
\thesisload
\makeatletter
\def\thesis@biblatexiso@fix@package{iso-numeric.bbx}
\def\thesis@biblatexiso@fix@end{\relax}
\newif\ifthesis@biblatexiso@fix@
\thesis@biblatexiso@fix@false
\def\thesis@biblatexiso@fix@next#1,{%
  \def\thesis@biblatexiso@fix@current{#1}%
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@package
    \thesis@biblatexiso@fix@true
  \fi
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@end
    \expandafter
    \@gobble
  \fi
  \thesis@biblatexiso@fix@next
}
\expandafter\expandafter\expandafter\thesis@biblatexiso@fix@next\@filelist,\relax,
\ifthesis@biblatexiso@fix@
  \defbibenvironment{bibliography}
    {\list%
       {\MethodFormat}%
       {\setlength{\labelwidth}{\labelnumberwidth}%
        \setlength{\leftmargin}{\labelwidth}%
        \setlength{\labelsep}{\biblabelsep}%
        \addtolength{\leftmargin}{\labelsep}%
        \setlength{\itemsep}{\bibitemsep}%
        \setlength{\parsep}{\bibparsep}}%
        \renewcommand*{\makelabel}[1]{\hss##1}
        }%
    {\endlist}%
  {\item}%
\fi
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% The packages I use, my definitions, etc. %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for subfigures
\usepackage{subcaption}

% for writing nice pseudocode...
\usepackage{algpseudocode}
% ...and a float wrapper for them
\usepackage{algorithm}

\usepackage{mathtools}

% for checking for | in definition of set
\usepackage{xstring}

% for \set{}
\usepackage{braket}
% for notation { x | P(x)} we will use command \setbuilder
\let\setbuilder\set
% for {1,2,3}
\newcommand{\simpleset}[1]{\{{#1}\}}
% based on whether | is in the argument either use set builder notation or simple set notation
\renewcommand{\set}[1]{\normalexpandarg\IfSubStr{#1}{|}{\setbuilder{#1}}{\simpleset{#1}}}
%\renewcommand{\set}[1]{\simpleset{#1}}

% for semantic symbols [[ and ]]
\usepackage{stmaryrd}

% for nicer looking substitutions in formulas
\usepackage{nicefrac}

% for writing out rules of DQBF in NNF
\usepackage{ebproof}

\usepackage{tikz}
\usetikzlibrary{arrows.meta,automata,positioning}

% for generating some text
\usepackage{blindtext}

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[chapter] %% The numbering of theorems
                               %% will be reset after each chapter.
\newtheorem{lemma}[theorem]{Lemma}         %% The numbering of lemmas
\newtheorem{corollary}[theorem]{Corollary} %% and corollaries will
                               %% share the counter with theorems.
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

% [[ #1 ]]
\newcommand{\seman}[1]{\left\llbracket {#1} \right\rrbracket}
% substitution for formulas: [phi'/phi] - \substitute{phi}{phi'}
\newcommand{\substitute}[2]{\left[ \nicefrac{#2}{#1} \right]}
% the set of all boolean formulas over #1
\newcommand{\BF}[1]{\mathbf{\Phi}_{#1}^{\normalfont{\text{\tiny BF}}}}
%\newcommand{\BF}[1]{BF(#1)}
% the set of all dependency quantified boolean formulas over #1
\newcommand{\DQBF}[1]{\mathbf{\Phi}_{#1}^{\normalfont{\text{\tiny DQBF}}}}
%\newcommand{\DQBF}[1]{\mathbf{\Phi}_{#1}^{\normalfont{\text{\tiny dnnf}}}}
% the set of all valuations over #1
\newcommand{\valtns}[1]{\mathbf{A}_{#1}}
% the set of all Boolean functions over #1
\newcommand{\BFuncs}[1]{\mathbb{F}_{#1}}

% the set of all variables in formula #1
\newcommand{\vars}[1]{V_{#1}}
% the set of existential variables for formula #1
\newcommand{\evars}[1]{V_{#1}^{\exists}}
% the set of universal variables for formula #1
\newcommand{\uvars}[1]{V_{#1}^{\forall}}
% the set of free variables for formula #1
\newcommand{\fvars}[1]{V_{#1}^{\mathrm{free}}}
% the set of quantified variable for formula #1
\newcommand{\qvars}[1]{V_{#1}^{Q}}

% support set of boolean function #1
\newcommand{\supp}[1]{\mathrm{supp}(#1)}

% set of Skolem functions mapping for formula #1
\newcommand{\Scands}[1]{\mathbb{S}_{#1}}

% logical equality (like \lor or \land)
\newcommand{\lequal}{\Leftrightarrow}

% space between quantifiers and formula
\newcommand{\itholds}{\,}

% complexity classes
\newcommand{\ComplexityFont}[1]{\mathsf{#1}}
\newcommand{\PSPACE}{\ComplexityFont{PSPACE}}
\newcommand{\NP}{\ComplexityFont{NP}}
\newcommand{\NEXPTIME}{\ComplexityFont{NEXPTIME}}

%\renewcommand{\phi}{\varphi}

% for fixing overflowing in bibliography
\hyphenation{Chris-toph}
%\hyphenation{Mat-thias}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\chapter{Introduction}

\chapter{Theory}
In this chapter we give the definitions and some theoretical results of dependency quantified Boolean formulas (DQBFs) and binary decision diagrams (BDDs). For DQBFs we build up from Boolean formulas (BFs) to which we add quantifiers resulting in quantified Boolean formulas (QBFs). After this, we add explicit dependencies to the definition of QBFs which results in DQBFs. For these we give two forms, one that can only have quantifiers at the beginning of the formula and one that allows them deeper in the formula. For the latter we give some rules for transformation of DQBFs which we use for developing our solver in Chapter~\ref{chap:algorithm}. 

In the last section of this chapter we define BDDs and recall some of their properties.

\section{Boolean Formulas}
We first start with defining Boolean formulas. For these we need a set of variables $V = \set{x_1, \dots, x_n}$ for which we can define a valuation function $v\colon V \to \{0,1\}$ that says whether each variable is true or false. We then define Boolean formulas as variables connected by logical operatives \emph{and} (${\land}$), \emph{or} (${\lor}$) and \emph{negation} (${\neg}$).

\begin{definition}
Let $V = \set{x_1, \dots, x_n}$ be a set of variables. The set of \emph{Boolean formulas} (BFs) \emph{over $V$}, denoted by $\BF{V}$, is defined as the smallest set fulfilling these conditions:
\begin{itemize}
    \item $0,1 \in \BF{V}$,
    \item $x \in \BF{V}$ if $x \in V$,
    \item $(\phi_1 \land \phi_2) \in \BF{V}$ if $\phi_1, \phi_2 \in \BF{V}$,
    \item $(\phi_1 \lor \phi_2) \in \BF{V}$ if $\phi_1, \phi_2 \in \BF{V}$,
    \item $\neg\phi \in \BF{V}$ if $\phi \in \BF{V}$.
\end{itemize}
\end{definition}
By $\phi\substitute{\phi_1}{\phi_2}$, where $\phi,\phi_1,\phi_2 \in \BF{V}$, we denote the BF $\phi$ where each occurrence of $\phi_1$ is replaced by $\phi_2$. We also use $(\phi_1 \lequal \phi_2)$ as a shorthand for the formula $((\phi_1 \land \phi_2) \lor (\neg \phi_1 \land \neg \phi_2))$.

A function $v\colon V \to \set{0,1}$ is called a \emph{valuation} over the set of variables $V$. A set of all valuations over $V$ is denoted by $\valtns{V}$. An \emph{evaluation} of $\phi \in \BF{V}$ in a valuation $v \in \valtns{V}$, denoted $v(\phi)$, is defined as %can extend this valuation to $\BF{V}$%, $v\colon \BF{V} \to \set{0,1}$ where
\begin{itemize}
    \item if $\phi = 0$ then $v(\phi) = 0$,
    \item if $\phi = 1$ then $v(\phi) = 1$,
    \item if $\phi = x_i$ where $x_i \in V$, then $v(\phi) = v(x_i)$,
    \item if $\phi = \neg\phi'$, then $v(\phi) = 1$ if $v(\phi') = 0$, otherwise $v(\phi) = 0$,
    \item if $\phi = (\phi_1 \land \phi_2)$, then $v(\phi) = 1$ if both $v(\phi_1) = 1$ and $v(\phi_2) = 1$, otherwise $v(\phi) = 0$, and
    \item if $\phi = (\phi_1 \lor \phi_2$), then $v(\phi) = 1$ if $v(\phi_1) = 1$ or $v(\phi_2) = 1$, otherwise $v(\phi) = 0$.
\end{itemize}
Each $\phi \in \BF{V}$ represents a \emph{Boolean function} $f_{\phi}\colon \valtns{V} \to \set{0,1}$ \emph{over $V$} such that $f_{\phi}(v) = v(\phi)$. Conversely, for each Boolean function we can find a BF representing it. The set of all Boolean functions over $V$ is denoted by $\BFuncs{V}$. The \emph{support set} $\supp{f}$ of Boolean function $f$ is defined as the set of variables occurring in a BF $\phi$ where $\phi$ represents $f$ and from all the BFs representing $f$, $\phi$ has the smallest number of variables occurring in it. That is, changing the values of variables that are not in the support set do not change the output value of $f$.


An important notion for BFs is \emph{satisfiability}. We say that $\phi \in \BF{V}$ is \emph{satisfiable} if there exists valuation $v \in \valtns{V}$ in which $\phi$ is true, that is $v(\phi) = 1$. Let $\phi_1, \phi_2 \in \BF{V}$. We say that they are \emph{equivalent}, denoted $\phi_1 \equiv \phi_2$, if for all valuations $v$ it holds that $v(\phi_1) = v(\phi_2)$. If they are either both satisfiable or they are both unsatisfiable, we call them \emph{equisatisfiable}, denoted $\phi_1 \approx \phi_2$.

\begin{example}
\label{ex:BF:prenex}
Let
\[\phi = ((x_1 \land x_2) \lequal (y_1 \lequal y_2)).\]
This formula says that if both $x_1$ and $x_2$ are true, then $y_1$ and $y_2$ must be same, otherwise they must be different. It is satisfiable, because in valuation $v$ such that $v(x_1) = v(x_2) = v(y_1) = v(y_2) = 1$ it holds that $\phi$ is evaluated to $v(\phi)=1$. The Boolean function $f_{\phi}$ that $\phi$ represents has support set $\supp{f_{\phi}} = \set{x_1, x_2, y_1, y_2}$.
%This formula is also equisatisfiable to formula 
%\[\phi' = (x \land y) \lor \neg x\] 
%because $\phi'$ is also satisfiable: in valuation $v'$ where $v'(x) = v'(y) = 1$ it holds that $v'(\phi') = 1$. Notice that even though $\phi$ and $\phi'$ have different variables, the equisatisfiability still holds. However, $\phi \not= \phi'$ because if we add to $v'$ that $v'(x_1) = v'(x_2) = v'(y_1) = 1$ and $v'(y_2) = 0$ we get that $v'(\phi) \not= v'(\phi')$.
\end{example}

\subsection{Conjuctive Normal Form}
\label{sec:BF:CNF}
To work with BFs it is usually easier to have them in some special form. The first one we define is called conjuctive normal form.

\begin{definition}
We say that boolean formula $\phi \in \BF{V}$ is in \emph{conjuctive normal form} (CNF) if there exist $\phi_1,\dots,\phi_n \in \BF{V}$ where
\[\phi = \phi_1 \land \dots \land \phi_n\]
and
\[\phi_i = l_{i1} \lor \dots \lor l_{i{m_i}}\]
for each $i = 1, \dots, n$, and for each $l_{ij}$ where $j \in \set{1,\dots,m_i}$ either $l_{ij} = x$ or $l_{ij} = \neg x$ for some $x \in V$.
\end{definition}
Formulas $\phi_1,\dots,\phi_n$ are called clauses and $l_{ij}$ are called literals. That is BF is in CNF if it is a conjuction of clauses which are disjunctions of literals, where literal is either a variable or its negation.

\begin{example}
The formula
\[\phi_{CNF} = (x \lor \neg y) \land (\neg x \lor y)\]
is in CNF with clauses $(x \lor \neg y)$ and $(\neg x \lor y)$ and literals $x,\neg y, \neg x$ and $y$.
\end{example}

For every BF $\phi$ there exists an equivalent formula in CNF which can be exponentially larger than $\phi$. However, by using Tseytin transformation~\cite{Tseitin} we can create an equisatisfiable BF $\phi_{CNF}$ which is only polynomially larger than the original BF $\phi$.

\subsection{Negation Normal Form}
\label{sec:BF:NNF}
We say that BF $\phi$ is in negation normal form (NNF) if negation occurs only in front of the variable. Each BF $\phi$ can be easily transformed into an equivalent BF $\phi'$ in NNF by applying these three rules:
\begin{enumerate}
    \item $\neg(\phi_1 \land \phi_2) \equiv (\neg\phi_1 \lor \neg\phi_2)$ 
    \item $\neg(\phi_1 \lor \phi_2) \equiv (\neg\phi_1 \land \neg\phi_2)$
    \item $\neg\neg x \equiv x$
\end{enumerate}
\begin{example}
Formula $\neg (x_1 \land (x_2 \lor \neg x_3))$ that is not in NNF is by using the first rule equal to $(\neg x_1 \lor \neg(x_2 \lor \neg x_3))$ which is by using the second rule equal to $(\neg x_1 \lor (\neg x_2 \land \neg\neg x_3))$. Finally, by using the third rule we get $(\neg x_1 \lor (\neg x_2 \land x_3))$ which is in NNF.
\end{example}

\section{Quantified Boolean Formulas}
Having defined BFs, we can move to the next step on the way to defining DQBF by adding quantifiers. We add existential (${\exists}$) and universal (${\forall}$) quantifiers bounded to variables which results in the definition of \emph{quantified Boolean formulas} (QBFs). Usually, definitions of QBFs allow quantifiers everywhere inside formula but we only give definition of one special form of QBFs called prenex normal form. In this form, QBFs allow quantifiers only at the beginning of the formula. However, this does not change the expressibility as it is possible to transform every QBF into prenex normal form~\cite{prenexingQBFs}.

\begin{definition}
Let $V = \set{x_1,\dots,x_n}$ be a set of variables and $\phi \in \BF{V}$. A \emph{quantified Boolean formula} (QBF) $\psi$ \emph{over $V$} in \emph{prenex normal form} is given by
\[\psi = Q_1 x_1 Q_2 x_2 \dots Q_n x_n \itholds \phi\]
where $x_i \in V$ are distinct for all $i \in \set{1,2,\dots,n}$ and $Q_i \in \set{{\exists}, {\forall}}$.
\label{def:QBF}
\end{definition}

The BF $\phi$ is called the \emph{matrix} of $\psi$ and $Q_1 x_1 Q_2 x_2 \dots Q_n x_n$ is called the \emph{quantifier prefix} of $\psi$. A variable $x_i$ is called \emph{existential} if $Q_i = \exists$ and \emph{universal} if $Q_i = \forall$. The set of all existential variables of QBF $\psi$ is denoted by $\evars{\psi}$ and the set of all universal variables of $\psi$ is denoted by $\uvars{\psi}$. We define a level function $l\colon V \to \mathbb{N}$ which maps to each variable the number of quantifiers occurring before the variable in the formula. That is the variable $x_i \in V$ from QBF $\psi$ of Definition~\ref{def:QBF} has level $l(x_i) = i$. We denote the set of variables with level less than some $n \in \mathbb{N}$ as $V_{\psi}^{<n} = \set{x \in V | l(x) < n}$.

Again, we define satisfiability. Usually, satisfiability for QBFs is defined trough valuation function as in BFs case where evaluation of QBFs follows the same rules as BFs with two newly added rules for quantifiers:
\begin{itemize}
    \item $v(\forall x Q_i x_i \dots Q_n x_n \itholds \phi) = 1$ if both $v(Q_i x_i \dots Q_n x_n \itholds \phi\substitute{x}{0}) = 1$ and $v(Q_i x_i \dots Q_n x_n \itholds \phi\substitute{x}{1}) = 1$, otherwise it equals $0$,
    %TODO: check if the linebreak is not obvious
    \item $v(\exists x Q_i x_i \dots Q_n x_n \itholds \phi) = 1$ if $v(Q_i x_i \dots Q_n x_n \itholds \phi\substitute{x}{0}) = 1$ or \\ $v(Q_i x_i \dots Q_n x_n \itholds \phi\substitute{x}{1}) = 1$, otherwise it equals $0$.
\end{itemize}
We follow different but equal definition based on Skolemization, which replaces each existential variable $x$ by some Boolean function over universal variables with lower level than $x$. This is better suited to show a correspondence of QBFs and DQBFs when we add dependencies in the next section. A QBF $\psi$ of Definition~\ref{def:QBF} is satisfiable if for each $x \in V_{\psi}^{\exists}$ there exists a function $s_{x} \in \BFuncs{\uvars{\psi}\cap V_{\psi}^{<l(x)}}$ (called \emph{Skolem function}) such that the matrix $\phi$ of $\psi$, where every $x \in \evars{\psi}$ is replaced by some BF that represents $s_x$, is evaluated to $1$ in every valuation $v\colon \uvars{\psi} \to \set{0,1}$.

\begin{example}
\label{ex:QBF:prenex}
Let 
\[\psi = \forall x_1 \forall x_2 \exists y_1  \exists y_2 \itholds ((x_1 \land x_2) \lequal (y_1 \lequal y_2))\]
be a QBF where the matrix is formula $\phi$ from Example~\ref{ex:BF:prenex}. This QBF is satisfiable because for all values of $x_1, x_2$ we can find values of $y_1$ and $y_2$ such that they are same if $x_1 = x_2 = 1$ and different otherwise. The Skolem functions for this formula are for example $s_{y_1}$ which is represented by BF $x_1 \land x_2$ and $s_{y_2}$ which is represented by BF $1$. If we replace existential variables with their Skolem functions we get BF
\[((x_1 \land x_2) \lequal ((x_1 \land x_2) \lequal 1))\]
which is true in all valuations.
\end{example}

\section{Dependency Quantified Boolean Formulas}
Quantifiers have expanded the succinctness of BFs quite considerably. However, there is still one drawback of QBFs --- quantified variable $x$ depends on all variables that are quantified before $x$ in the formula. The question arises whether it is possible to give a definition of formula where the dependency relation is somehow explicitly given. The answer is yes, we can use \emph{dependency quantified Boolean formulas} (DQBFs).

DQBFs allow existential variables to be non-linearly dependent on the set of universal variables by explicitly writing out the set of universal variables on which each existential variable is dependent. The universal variables from this set are then used as the support set of the Skolem function of the existential variable which allows for even greater succinctness of DQBFs over QBFs.  

We start with the definition of DQBFs in prenex normal form on which we explain the basic notions and then we give the definition of DQBFs in non-prenex negation normal form which allows quantifiers inside formulas. Following this, we give theorems that show which DQBFs are equisatisfiable and can be replaced with each other thus allowing us to eliminate or push quantifiers inside the formula.
%\begin{itemize}
%    \item pushing quantifiers inside formula,
%    \item elimination of quantified variables or
%    \item ????removal of universal variables from the dependency sets of existential variables.????
%\end{itemize}

\subsection{Prenex Normal Form}
The first definition of DQBF form called prenex normal form is an analogy of the prenex normal form of QBFs.

\begin{definition}
  Let $V = \set{x_1, \dots, x_n, y_1, \dots, y_m}$ be a set of variables and $\phi \in \BF{V}$ a BF over $V$. A \emph{dependency quantified Boolean formula} (DQBF) $\psi$ in \emph{prenex normal form} (PNF) is given by
  \[\psi = \forall x_1 \dots \forall x_n \exists y_1 (D_1) \dots \exists y_m (D_m) \itholds \phi\]
  where $D_i \subseteq \set{x_1, \dots, x_n}$ for each $i \in \set{1,\dots,m}$ is a \emph{dependency set} of variable $y_i$.
  \label{def:DQBF:PNF}
\end{definition}
BF $\phi$ is the \emph{matrix} of $\psi$ and $\forall x_1 \dots \forall x_n \exists y_1 (D_1) \dots \exists y_m (D_m)$ the \emph{quantifier prefix} of $\psi$. We call the variables from $\evars{\psi} = \set{y_1,\dots,y_m}$ \emph{existential} and variables from $\uvars{\psi} = \set{x_1,\dots,x_n}$ \emph{universal}. We also say that $\psi$ is in \emph{prenex conjuctive normal form} (PCNF) if it is in PNF where the matrix is in CNF.



\begin{example}
Let us use an example by Rabe~\cite{DQBFProofSystem} to explain the meaning behind dependency sets. Let 
\[\psi = \forall x_1 \forall x_2 \exists y_1 (x_1) \exists y_2 (x_2) \itholds ((x_1 \land x_2) \lequal (y_1 \lequal y_2))\]
be a DQBF. The matrix is the BF $\phi$ from Example~\ref{ex:BF:prenex} and the quantifier prefix is very similar to the QBF from Example~\ref{ex:QBF:prenex} but now both $y_1$ and $y_2$ depend only on one variable, $x_1$ and $x_2$ respectively. The QBF was satisfiable but this DQBF is not. To show why, we can look at it as a game where $y_1$  and $y_2$ are trying to satisfy the formula and $x_1,x_2$ are trying to make it false. However, $y_1$ knows only how $x_1$ is behaving and similarly $y_2$ knows only what $x_2$ is doing. As explained in Example~\ref{ex:BF:prenex} the matrix says that if both $x_1$ and $x_2$ are true, then $y_1$ and $y_2$ should be same, otherwise they need to be different. However, this is not possible, because if for example both $y_1,y_2$ decide to be true (similarly for false) when their respective universal variables are true then if one of the universal variable change, for example $x_1$ turns to false, then $y_2$ does not know about this and stays true. In that case $y_1$ has to change the value to false so they become different. The same thing happens to $y_2$ if $x_2$ changes its value to false. So we get behaviour where both existential variables just copy the behaviour of their universal variable. But at the end, if both $x_1$ and $x_2$ change their values to false, then the values of $y_1$ and $y_2$ are the same (false) which makes the formula $\psi$ false.
\end{example}

With the example in mind, we define satisfiability for DQBF in PNF similarly to how satisfiability is defined for QBFs with Skolem functions. DQBF $\psi$ of Definition~\ref{def:DQBF:PNF} is \emph{satisfiable} if for each $y \in \evars{\psi}$ there exists a Skolem function $s_y \in \BFuncs{D_y}$ such that $\phi$, where each $y \in \evars{\psi}$ is replaced by a BF representing Boolean function $s_y$, evaluates to $1$ in all valuations $v\colon \uvars{\psi} \to \set{0,1}$.

\begin{example}
The possible Skolem functions $s_{y_1}$ for existential variable $y_1$ from the previous example are those that are represented by BFs $0$, $1$, $x_1$ or $\neg x_1$. For $y_2$ the Skolem functions $s_{y_2}$ can be those that are represented by BFs $0$, $1$, $x_2$ or $\neg x_2$. However, we cannot choose a pair $s_{y_1}$ and $s_{y_2}$ such that by replacing $y_1$ and $y_2$ with them, we get a BF that is true in all valuations. In the previous example we actually used $s_{y_1}$ represented by $x_1$ and $s_{y_2}$ represented by $x_2$, where we get BF
\[((x_1 \land x_2) \lequal (x_1 \lequal x_2))\]
which is obviously not true in all valuations.
\end{example}

\begin{remark}
QBFs in PNF can be seen as a special case of DQBFs in PNF where the dependency sets are linearly ordered. That is a DQBF $\psi$ where for each two dependency sets $D_{y_1}$ and $D_{y_2}$ it holds that either $D_{y_1} \subseteq D_{y_2}$ or $D_{y_2} \subseteq D_{y_1}$, can be easily transformed to QBF by reordering the quantifiers.
\end{remark}

\subsection{Negation Normal Form}
In this section we give the definition of the normal form of DQBF that is non-prenex. This allows quantifiers inside the formula. However, negation is only allowed in front of variables. %This restriction stems from the fact that prenex DQBFs are not syntactically closed under negation~\cite{NegationOfDQBFs}. %, therefore negation in front of some quantified subformula would make no sense.
This form is also not closed which means it allows free variables. These variables are not bounded by any quantifier thus the definition of satisfiability has to take them into consideration. The definitions in this section are taken from Ge-Ernst et al.~\cite{HQSquantifierLocalization}.


We first give the definition of the set $\DQBF{V}$ of DQBFs in \emph{negation normal form} where we use the rules form Figure~\ref{fig:DQBFrules}. Each rule has the list of conditions (over the line) that has to hold so that the resulting formula under the line is in $\DQBF{V}$. For each formula $\psi$ we also define the set of existential $\evars{\psi}$, universal $\uvars{\psi}$, and free $\fvars{\psi}$ variables. We also use $\qvars{\psi} = \evars{\psi} \cup \uvars{\psi}$ and $V_{\psi} = \qvars{\psi} \cup \fvars{\psi}$.  Furthermore, $\psi^{-v}$ results from $\psi$ where $v$ is removed from every dependency set in $\psi$. 

\begin{figure}[htp]
    \renewcommand{\arraystretch}{2}
    %\begin{centering}
    %\hspace*{-0.7cm}
    \begin{tabular}{ccccc}
        \multicolumn{2}{c}{rule} & $V_{.}^{\exists}$ & $V_{.}^{\forall}$ & $V_{.}^{\text{free}}$\\\hline
        {\begin{prooftree}
            \infer0{0 \in \DQBF{V}}
        \end{prooftree}}
        & {\begin{prooftree}
            \infer0{1 \in \DQBF{V}}
        \end{prooftree}}
        & $\emptyset$ & $\emptyset$ & $\emptyset$\\[5mm]
        {\begin{prooftree}
            \hypo{v \in V}
            \infer1{v \in \DQBF{V}}
        \end{prooftree}}
        %& $\emptyset$ & $\emptyset$ & $\set{v}$\\[5mm]
        & {\begin{prooftree}
            \hypo{v \in V}
            \infer1{\neg v \in \DQBF{V}}
        \end{prooftree}}
        & $\emptyset$ & $\emptyset$ & $\set{v}$\\[5mm]
        \multicolumn{2}{c}{{\begin{prooftree}
            \hypo{\psi_1 \in \DQBF{V}}
            \hypo{\psi_2 \in \DQBF{V}}
            \hypo{(\ref{disconjrule})}
            \infer3{(\psi_1 \land \psi_2) \in \DQBF{V}}
        \end{prooftree}}}
        & $\evars{\psi_1} \cup \evars{\psi_2}$ & $\uvars{\psi_1} \cup \uvars{\psi_2}$ & $\fvars{\psi_1} \cup \fvars{\psi_2}$\\[5mm] 
        \multicolumn{2}{c}{{\begin{prooftree}
            \hypo{\psi_1 \in \DQBF{V}}
            \hypo{\psi_2 \in \DQBF{V}}
            \hypo{(\ref{disconjrule})}
            \infer3{(\psi_1 \lor \psi_2) \in \DQBF{V}}
        \end{prooftree}}}
        & $\evars{\psi_1} \cup \evars{\psi_2}$ & $\uvars{\psi_2} \cup \uvars{\psi_2}$ & $\fvars{\psi_1} \cup \fvars{\psi_2}$\\[5mm]
        \multicolumn{2}{c}{{\begin{prooftree}
            \hypo{\psi \in \DQBF{V}}
            \hypo{v \in V \setminus \qvars{\psi}}
            \hypo{(\ref{existrule})}
            \infer3{\exists v(D_v)\itholds\psi^{-v} \in \DQBF{V}}
        \end{prooftree}}}
        & $\evars{\psi} \cup \set{v}$ & $\uvars{\psi}$ & $\fvars{\psi} \setminus \set{v}$ \\[5mm]
        \multicolumn{2}{c}{{\begin{prooftree}
            \hypo{\psi \in \DQBF{V}}
            \hypo{v \in V \setminus \qvars{\psi}}
            \infer2{\forall v\itholds\psi \in \DQBF{V}}
        \end{prooftree}}}
        & $\evars{\psi}$ & $\uvars{\psi} \cup \set{v}$ & $\fvars{\psi} \setminus \set{v}$\\[5mm]
    \end{tabular}
    %\end{centering}
    \flushleft{where (\ref{disconjrule}) refers to}
    \begin{multline}
        \tag{1} 
        \label{disconjrule}
        \qvars{\psi_1} \cap \qvars{\psi_2} = \emptyset \text{\quad and\quad} \fvars{\psi_1} \cap \qvars{\psi_2} = \emptyset \text{\quad and\quad} \fvars{\psi_2} \cap \qvars{\psi_1} = \emptyset
    \end{multline}
    \flushleft{and (\ref{existrule}) refers to}
    \begin{equation}
        \tag{2} 
        \label{existrule}
        D_v \subseteq V \setminus (\qvars{\psi} \cup \set{v})
    \end{equation}
    \caption{Rules defining the syntax of DQBFs in NNF (based on Ge-Ernst et al.~\cite{HQSquantifierLocalization}).}
    \label{fig:DQBFrules}
\end{figure}

\begin{definition}
  Let $V$ be a set of variables. The set $\DQBF{V}$ of \emph{DQBFs in negation normal form} (NNF) over $V$ is defined to be the smallest set satisfying the rules from Figure~\ref{fig:DQBFrules}.
\end{definition}
\begin{remark}
In the definition by Ge-Ernst et al.~\cite{HQSquantifierLocalization} the last two rules in Figure~\ref{fig:DQBFrules} have condition $v \in \fvars{\psi}$ instead of $v \in V \setminus \qvars{V}$. This condition is too strong and does not allow some formulas which are valid. For example, as we show in the next section, we can transform DQBFs by pushing quantifiers inside the formula and this way we can end up with a formula $\forall x \itholds \psi$ where $x \not\in V_{\psi}$. However, according to the aforementioned definition this would not be a valid formula.
\end{remark}

\begin{remark}
Notice that each DQBF $\psi$ in PNF can be transformed into DQBF $\psi'$ in NNF by transforming the matrix of $\psi$ to NNF as explained in Section~\ref{sec:BF:NNF}.
\end{remark}

By $\psi\substitute{x_1}{x_2}$ where $\psi \in \DQBF{V}$, $x_1, x_2 \in V$, $x_2 \not\in V_{\psi}$ we denote the DQBF $\psi$ in which every occurence of $x_1$ (even in the dependency sets) is replaced by $x_2$. If $x_1 \not\in \qvars{\psi}$ and is not in any dependency set in $\psi$ then by $\psi\substitute{x_1}{\kappa}$, where $\kappa\in\set{0,1}$, we denote the DQBF $\psi$ in which every occurence of $x_1$ is replaced by $\kappa$.

% semantics
The definition of satisfiability of DQBF in NNF follows the same way as in the previous section but now we have to decide what to do with free variables. In non-prenex case of QBFs, free variables are usually assumed to be existential variables with quantifiers at the beginning of the formula. In DQBF case this means that free variables would have empty dependency sets so the definition needs to follow that. We first define mapping, called \emph{Skolem functions mapping} which maps to each existential and free variables some Skolem function fulfilling conditions set by dependency sets. Then we define \emph{semantics} of DQBFs in NNF as the set of Skolem functions mappings which satisfy the formula.

\begin{definition}[Skolem Functions Mapping]
  Let $\psi \in \DQBF{V}$. We say that mapping $s\colon (\evars{\psi} \cup \fvars{\psi}) \to \BFuncs{\uvars{\psi}}$ is a \emph{Skolem functions mapping} of $\psi$ if
  \begin{itemize}
      \item $\supp{s(v)} \subseteq (D_v \cap \uvars{\psi})$ for all $v \in \evars{\psi}$ and
      \item $\supp{s(v)} = \emptyset$ for all $v \in \fvars{\psi}$, i.e. $s(v)$ is either represented by $0$ or $1$.
  \end{itemize}
\end{definition}

The set of all Skolem functions mappings of $\psi$ is denoted by $\Scands{\psi}$. If $s \in \Scands{\psi}$, we write $s(\psi)$ for the formula that results from $\psi$ by replacing each existential and free variable $v$ by a BF that represents $s(v)$ and omitting all quantifiers from $\psi$. This results in a BF containing only variables from $\uvars{\psi}$.

\begin{definition}[Semantics]
  Let $\psi \in \DQBF{V}$. We define the \emph{semantics} $\seman{\psi}$ of $\psi$ as follows:
  \[\seman{\psi} = \set{s \in \Scands{\psi} | v(s(\psi))=1 \text{ for all } v \in \valtns{\uvars{\psi}}}.\]
\end{definition}
Formula $\psi$ is \emph{satisfiable} iff $\seman{\psi} \not= \emptyset$ and the elements of $\seman{\psi}$ are \emph{satisfiying} Skolem functions mappings of $\psi$. We say that two formulas $\psi_1$ and $\psi_2$ are \emph{equisatisfiable}, denoted $\psi_1 \approx \psi_2$, if both are either satisfiable or both are unsatisfiable.
\begin{example}
\label{ex:DQBF:NNF}
To explain the semantics of DQBF in NNF we use the example by Ge-Ernst et al.~\cite{HQSquantifierLocalization}:
\[\psi = \forall x_1 \forall x_2\itholds ((x_1 \lequal x_2) \lor \exists y (x_2)\itholds \neg(x_1 \lequal y)).\]
The meaning behind this formula is that either $x_1$ and $x_2$ are the same or there is some $y$ which is dependent only on $x_2$ which is different from $x_1$. The Skolem functions mappings of $\psi$ are then $\Scands{\psi} = \{y\mapsto f_0$, $y\mapsto f_1$, $y\mapsto f_{x_2}$, $y\mapsto f_{\neg x_2}\}$ where $f_0$ is the Boolean function represented by Boolean formula $0$, $f_1$ is represented by $1$, $f_{x_2}$ by $x_2$ and $f_{\neg x_2}$ by $\neg x_2$. It is obvious that only $s = y \mapsto f_{x_2}$ is a satisfying mapping of $\psi$, since only $s(\psi) = ((x_1 \lequal x_2) \lor \neg(x_1 \lequal x_2))$ is true in all valuations.
\end{example}

\subsection{Shifting Quantifiers}
\label{sec:quantLocalization}
Now that we have defined DQBFs we give some theoretical results which show the equisatisfiability of different DQBFs which can result in their simplification. These results can be then used for developing a DQBF solver which checks whether an input DQBF is satisfiable or not.

We start with a theorem that show some rules by which we can push (extract) quantifiers in (from) the formula. %The first theorem is from~\cite[Theorem 3]{HQSquantifierLocalization} where ... is replaced by ... from~\cite[Theorem 4]{HQSquantifierLocalization}

%\let\oldtheequation\theequation
%\renewcommand{\theequation}{\alph{equation}}
\begin{theorem}[{\cite[Theorems 3,4]{HQSquantifierLocalization}}]
\label{thrm:quantLocalEq}
  Let ${\diamond} \in \set{{\land},{\lor}}$ and $\psi,\psi_1,\psi_2 \in \DQBF{V}$. We assume that $x'$ and $y'$ are fresh variables, which do not occur in $\psi,\psi_1$ and $\psi_2$. Then we have
  \begin{align}
      %\forall x : \psi &\approx \psi \text{, if } x \not\in V_{\psi} \\
      \forall x \itholds (\psi_1 \land \psi_2) &\approx \left(\forall x \itholds \psi_1 \land \forall x' \itholds \psi_2\substitute{x}{x'}\right) \tag{a} \label{loc:unconj1} \\
      \forall x \itholds (\psi_1 \land \psi_2) &\approx \left(\psi_1^{-x} \land \forall x \itholds \psi_2\right) \text{, if } x \not\in V_{\psi_1} \tag{b} \label{loc:unconj2} \\
      \forall x \itholds (\psi_1 \diamond \psi_2) &\approx \begin{multlined}[t][3cm]\left(\psi_1 \diamond \forall x \itholds \psi_2\right) \text{, if } x \not\in V_{\psi_1} \tag{c} \label{loc:undisj} \\
      \text{ and } x \not\in D_y \text{ for all } y \in \evars{\psi_1}\end{multlined} \\
      \exists y(D_y) \itholds (\psi_1 \lor \psi_2) &\approx \left(\exists y(D_y) \itholds \psi_1 \lor \exists y'(D_y) \itholds \psi_2\substitute{y}{y'}\right) \tag{d} \label{loc:exdisj} \\
      \exists y(D_y) \itholds (\psi_1 \diamond \psi_2) &\approx \left(\psi_1 \diamond \exists y(D_y) \itholds \psi_2\right) \text{, if } y \not\in V_{\psi_1} \tag{e} \label{loc:exboth} \\
      \exists y_1(D_{y_1})\exists y_2(D_{y_2}) \itholds \psi &\approx \exists y_2(D_{y_2}) \exists y_1(D_{y_1}) \itholds \psi \tag{f} \label{loc:exswap} \\
      \forall x_1\forall x_2 \itholds \psi &\approx \forall x_2\forall x_1 \itholds \psi \tag{g} \label{loc:unswap} \\
      \forall x\exists y(D_y) \itholds \psi &\approx \exists y(D_y)\forall x \itholds \psi\text{, if } x \not\in D_y. \tag{h} \label{loc:bothswap}
  \end{align}
\end{theorem}
%\renewcommand{\theequation}{\oldtheequation}

To make these rules more usable for DQBF in NNF we have to show that they also work while replacing subformulas. Except for~\eqref{loc:unconj2}, this was not proven by Ge-Ernst et al.~\cite{HQSquantifierLocalization} even though they used it for replacing subformulas. As we will show, this was used erroneously because the rule~\eqref{loc:exdisj} does not generally hold. However, for other rules there is no problem as the next theorem shows. % that if DQBFs from the previous theorem occur as subformulas of DQBF $\psi$ they can be replaced without changing the satisfiability of $\psi$. 

\begin{theorem}
  \label{thrm:quantLocalSubformulas}
  Let $\psi \in \DQBF{V}$, $\phi$ be the left side formula and $\phi'$ be the right side formula  from the same equality other than~\eqref{loc:exdisj} from Theorem~\ref{thrm:quantLocalEq} where $\phi$ is a subformula of $\psi$. Again, the same assumptions for $x'$ and $y'$ variables hold as in Theorem~\ref{thrm:quantLocalEq} but also they do not occur in $\psi$. Then $\psi \approx \psi'$ where $\psi'$ results from $\psi$ by replacing $\phi$ with $\phi'$.
\end{theorem}
\begin{proof}
  \eqref{loc:unconj1} We show that $\seman{\psi} \not= \emptyset$ iff $\seman{\psi'} \not= \emptyset$. First, let $s \in \seman{\psi}$. We now show that for $s'$, where $s'(y) = s(y)\substitute{x}{x'}$ for $y \in \evars{\phi'}$ and $s'(y) = s(y)$ otherwise, it holds $s' \in \seman{\psi'}$. Let $v \in \valtns{\psi'}$. We need to show that $v(s'(\psi')) = 1$. Because $s \in \seman{\psi}$ it holds that $v(s(\psi)) = 1$. For the case that $v(x') = v(x)$ we get $v(s(\psi)) = v(s'(\psi'))$, because BFs $s(\psi)$ and $s(\psi')$ differ only in some replacements of $x$ by $x'$. Therefore we assume that $v(x') \not= v(x)$. We know that $\psi$ and $\psi'$ differ only in the formulas $\phi$ and $\phi'$, therefore we can only focus on the case that the value of $v(s(\psi))$ depends on the subformula $s(\phi)$ (that is the value of $v(s(\psi))$ would change if the value of $v(s(\phi))$ changed). Also, $\psi$ is in NNF, which means that in the tree of operations, negation cannot be before $\phi$. This means that we can focus only on the case where $v(s(\phi)) = 1$, otherwise the value of $v(s(\psi))$ would not depend on the subformula $s(\phi)$. This means we need to show that $v(s'(\phi')) = 1$. We have that for $v(s(\phi)) = v(s(\forall x \itholds (\psi_1 \land \psi_2))) = v(s(\psi_1) \land s(\psi_2))$ to be equal to one, it has to hold that $v(s(\psi_1)) = 1$ and $v(s(\psi_2)) = 1$. Also, for $v'$ which is equal to $v$, except that $v'(x) \not= v(x)$, it holds that $v'(s(\psi)) = 1$. This is from the assumption that the value of $v(s(\psi))$ depends on $v(s(\phi))$, because $x$ is only in $\phi$. This means that $v'(s(\psi_2)) = 1$. Also $v'(s(\psi_2)) = v(s'(\psi_2\substitute{x}{x'}))$, because $v'(x) = v(x')$. All in all, we get $v(s(\psi_1)) = v(s'(\psi_1)) = 1$ and $v(s'(\psi_2\substitute{x}{x'})) = 1$ therefore $v(s'(\phi')) = v(s'((\forall x \itholds \psi_1) \land (\forall x' \itholds \psi_2\substitute{x}{x'}))) = 1$.
  
  For the other direction, let $s' \in \seman{\psi'}$. It can be easily shown by similar argument that $s$, where $s(y) = s'(y)\substitute{x'}{x}$ for $y \in \psi_2$ and $s(y) = s'(y)$ otherwise, is a satisfying Skolem functions mapping of $\psi$.
  
  \eqref{loc:unconj2} This was proven by Ge-Ernst et al.~\cite[Theorem 4]{HQSquantifierLocalization}.
  
  %(\ref{loc:exdisj}) Again, we show that $\seman{\psi} \not= \emptyset$ iff $\seman{\psi'} \not= \emptyset$. First, let $s \in \seman{\psi}$. It is easy to see, that $s'$, where $s'(y) = s'(y') = s(y)$ and for other variables $s'(v) = s(v)$, is a satisfying Skolem functions mapping of $\psi'$, because $s(\psi)$ and $s(\psi')$ are the same BFs. For the other direction, let $s' \in \seman{\psi'}$. Using similar arguments as in the case (\ref{loc:unconj1}) and realising that disjunction valuates to true if either of its operators is true, we can see that at least one of $s_1$ and $s_2$, where $s_1(y) = s'(y)$, $s_2(y) = s'(y')$ and for other variable $s_1(v) = s_2(v) = s'(v)$, is a satisfying Skolem functions mapping of $\psi$.
  
  \eqref{loc:undisj}\eqref{loc:exboth}\eqref{loc:exswap}\eqref{loc:unswap}\eqref{loc:bothswap} Because $\uvars{\psi} = \uvars{\psi'}$, $\evars{\psi} = \evars{\psi'}$, and $\fvars{\psi} = \fvars{\psi'}$ and the dependency sets do not change, it holds that $\Scands{\psi} = \Scands{\psi'}$. Also, for any $s \in \Scands{\psi}$ it holds that $s(\psi)$ is the same BF as $s(\psi')$ which means that $\seman{\psi} = \seman{\psi'}$, therefore $\psi \approx \psi'$.
\end{proof}

As we already mentioned, the rule~\eqref{loc:exdisj} as it stands cannot be generally used for replacing subformulas. We show it on the following formula:
\[\forall x \exists y(\emptyset) \itholds ((x \land y) \lor (\neg x \land \neg y)).\]
It is obviously not satisfiable because whether $s(y) = 0$ or $s(y) = 1$ we always can find valuation in which both disjuncts are not true. However if we assumed that rule~(\ref{loc:exdisj}) can be also used for subformulas we would get
\[\forall x \itholds (\exists y(\emptyset) \itholds (x \land y) \lor \exists y'(\emptyset) \itholds (\neg x \land \neg y')),\]
which is satisfiable for $s$ where $s(y) = 1$ and $s(y') = 0$. To fix this, we need to restrict the variables that can occur in the disjuncts. When we look at this formula, it would appear that the problem arises from having universal variable $x$ on which $y$ is not dependent in both disjuncts. However, we can find an example when even if both disjuncts contain different sets of universal variables (other than the ones from $D_y$), this rule does not work. For example for
\[\forall x_1 \forall x_2 \itholds (\exists y(\emptyset) \itholds ((x_1 \land y) \lor (x_2 \land \neg y)) \lor (\neg x_1 \land \neg x_2)),\]
which is not satisfiable, we have that $(x_1 \land y)$ contains $x_1$ which is not in $(x_2 \land \neg y)$ and $x_2$ is only in the second disjunct. However, after applying the rule~\eqref{loc:exdisj} we get
\[\forall x_1 \forall x_2 \itholds ((\exists y(\emptyset) \itholds (x_1 \land y) \lor \exists y'(\emptyset) \itholds (x_2 \land \neg y')) \lor (\neg x_1 \land \neg x_2)),\]
which becomes satisfiable. The problem here is that $x_1$ and $x_2$ are in $(\neg x_1 \land \neg x_2)$ which is outside the subformula on which we are applying the rule $\eqref{loc:exdisj}$. Therefore, we can put in a condition, that the sets of universal variables (except the ones from $D_y$) from the disjuncts are disjoint and as the next theorem shows, it is enough that universal variables from one of these disjuncts are not ouside this subformula. We also need to not only look at the universal variables occurring in the disjuncts, but also at the ones from the dependency sets of existential variables occurring in the disjuncts.

\begin{theorem}
  Let $\psi,\psi_1,\psi_2 \in \DQBF{V}$ such that $\exists y(D_y) \itholds (\psi_1 \lor \psi_2)$ is a subformula of $\psi$ and $y'$ be a new variable not occurring in $\psi, \psi_1$ or $\psi_2$. Let 
  \[A_{\psi_1} = \Set{x \in \uvars{\psi} \setminus D_y | x \in \vars{\psi_1} \text{ or } x \in D_{y_1} \text{ for some } y_1 \in \vars{\psi_1} \cap \evars{\psi}}\]
  and 
  \[A_{\psi_2} = \Set{x \in \uvars{\psi} \setminus D_y | x \in \vars{\psi_2} \text{ or } x \in D_{y_2} \text{ for some } y_2 \in \vars{\psi_2} \cap \evars{\psi}}.\] 
  %\[\fvars{\psi_1 \lor \psi_2} \cup \evars{\psi_1 \lor \psi_2} \subseteq D_y \cup \fvars{\psi} \cup \Set{y' \in \evars{\psi} | D_y' \subseteq D_y \cup \uvars{\psi_1 \lor \psi_2}}.\] 
  Assume that $A_{\psi_1} \cap A_{\psi_2} = \emptyset$ and the variables from $A_{\psi_1}$ (or $A_{\psi_2}$) do not occur in $\psi$ outside the subformula $\exists y(D_y) \itholds (\psi_1 \lor \psi_2)$ or in the dependency set of some existential variable in $\psi$ outside the subformula $\exists y(D_y) \itholds (\psi_1 \lor \psi_2)$. Then $\psi \approx \psi'$ where $\psi'$ results from $\psi$ by replacing the subformula $\exists y(D_y) \itholds (\psi_1 \lor \psi_2)$ by \[\left(\exists y(D_y) \itholds \psi_1 \lor \exists y'(D_y) \itholds \psi_2\substitute{y}{y'}\right).\]
\end{theorem}
\begin{proof}
  We prove that $\seman{\psi} \not= \emptyset$ iff $\seman{\psi'} \not= \emptyset$. Let $\phi = \exists y(D_y) \itholds (\psi_1 \lor \psi_2)$ and $\phi' = (\exists y(D_y) \itholds \psi_1 \lor \exists y'(D_y) \itholds \psi_2\substitute{y}{y'})$. 
  
  First, let $s \in \seman{\psi}$. It is easy to see, that $s'$, where $s'(y) = s'(y') = s(y)$ and for other variables $s'(v) = s(v)$, is a satisfying Skolem functions mapping of $\psi'$, because $s(\psi)$ and $s(\psi')$ are the same BFs.
  
  Now, assume that $s' \in \seman{\psi'}$. Let $s$ be a Skolem function mapping of $\psi'$ such that for $v_{D_y} \in \valtns{D_y}$ we set 
  \begin{itemize}
      \item $s(y)(v_{D_y}) = s'(y)(v_{D_y})$ if for all valuations $v \in \valtns{\uvars{\psi}}$ with restriction to $D_y$ equal to $v_{D_y}$, for which it holds that the value of $v(s'(\psi'))$ depends on the subformula $s'(\phi')$, we have $v(s'(\psi_1)) = 1$,
      \item $s(y)(v_{D_y}) = s'(y')(v_{D_y})$ otherwise.
  \end{itemize}
  We set $s(v) = s'(v)$ for other variables. We show that $s \in \seman{\psi}$. Let $v \in \valtns{\uvars{\psi}}$ and $v_{D_y}$ its restriction to $D_y$. With similar reasoning as in the proof of case~\eqref{loc:unconj1} of Theorem~\ref{thrm:quantLocalSubformulas} we can assume that the value of $v(s'(\psi'))$ depends on the subformula $s'(\phi')$ and $v(s'(\phi')) = 1$. We need to show that $v(s(\phi)) = 1$. Because $s'(\phi')$ is a disjunction it has to hold that $v(s'(\psi_1)) = 1$ or $v(s'(\psi_2\substitute{y}{y'})) = 1$. If they're both equal to 1, then it does not matter whether $s(y)(v_{D_y}) = s'(y)(v_{D_y})$ or $s(y)(v_{D_y}) = s'(y')(v_{D_y})$, it will always hold that $v(s(\phi)) = 1$. If we have $v(s'(\psi_1)) = 0$ or $v(s'(\psi_2\substitute{y}{y'})) = 1$, then because from the way we defined $s$, we get $s(y)(v_{D_y}) = s'(y')(v_{D_y})$ and so $v(s(\psi_2)) = 1$ and therefore $v(s(\phi)) = 1$. For the last case, $v(s'(\psi_1)) = 1$ or $v(s'(\psi_2\substitute{y}{y'})) = 0$, we need to show that $s(y)(v_{D_y}) = s'(y)(v_{D_y})$. For that, it has to hold that for valuation $v' \in \valtns{\uvars{\psi}}$ with restriction to $D_y$ (labelled $v'_{D_y}$) equal to $v_{D_y}$ where the value of $v'(s'(\psi'))$ depends on the subformula $s'(\phi')$, it has to hold $v'(s'(\psi_1)) = 1$. Assume that this does not hold meaning $v'(s'(\psi_1)) = 0$. %Then, because the value of $v'(s'(\psi'))$ (which has to be equal to 1 from $s' \in \seman{\psi'}$) depends on the subformula $s'(\phi')$ it has to hold that $v'(s'(\phi')) = 1$ (again, the similar argument with $\phi'$ being in NNF as in proof of Theorem~\ref{thrm:quantLocalSubformulas}). 
  Let now $v'' \in \valtns{\uvars{\psi}}$ be a valuation such that $v''(x) = v'(x)$ for all $x \in A_{\psi_1}$ and $v''(x) = v(x)$ otherwise. This means that for restriction $A_{\psi_1}$ of $v''$ to $D_y$ it holds $v''_{D_y} = v_{D_y} = v'_{D_y}$. Because $s'(\psi_1)$ contains only variables from $A_{\psi_1} \cup D_y$ we have $v''(s'(\psi_1)) = v'(s'(\psi_1)) = 0$. Also $v''(s'(\psi_2\substitute{y}{y'})) = v(s'(\psi_2\substitute{y}{y'})) = 0$ which means $v''(s'(\phi')) = 0$. Furthermore, because variables from $A_{\psi_1}$ are not ``outside'' the subformula $s'(\phi')$ (from the assumption of the theorem) and all the ``outside'' variables were set to the same value as $v$, we get that the value of $v''(s'(\psi'))$ depends on the subformula $s'(\phi')$ (as was the case for $v$). However, this would mean (using the same argument of being in NNF as in the proof of Theorem~\ref{thrm:quantLocalSubformulas}) that $v''(s'(\phi')) = 1$ which is a contradiction.
  %First, the assumption $A_{\psi_1} \cap A_{\psi_2} \subseteq D_y$ tells us that for any two $s,s' \in \Scands{\psi}$ it holds that the variables occurring both in $s(\psi_1)$ and $s'(\psi_2)$ are from $D_y$. 
  %We will prove that for some $s$, where $s(y)$ is a combination of  $s'(y)$ and $s'(y')$, and $s(v) = s'(v)$ for other variables, is a satisfying Skolem functions mapping of $\psi'$. Let $v \in \valtns{\psi'}$ be a valuation and $v_{D_y}$ its restriction to $D_y$. With similar reasoning as in the proof of case~(\ref{loc:unconj1}) of Theorem~\ref{thrm:quantLocalSubformulas} we only need to show that $v(s(\phi)) = 1$ assuming that $v(s'(\phi')) = 1$. From this assumption we can infer that $v(s'(\psi_1)) = 1$ or $v(s'(\psi_2\substitute{y}{y'})) = 1$. Without loss of generality assume that $v(s'(\psi_1)) = 1$. Then we set $s(y)(v_{D_y})$ to $s'(y)(v_{D_y})$ which means that $v(s(\psi_1)) = 1$, therefore $v(s(\phi)) = 1$. However, we need to show that for different valuation $v' \in \valtns{\psi'}$ such that $v'(x) = v(x)$ for $x \in D_y$ (therefore $v_{D_y}' = v_{D_y}$) it also holds that $v'(s'(\psi_1)) = 1$ (and so $v'(s(\phi)) = 1$). Assume now it does not hold. For $v'(s'(\phi'))$ to be equal to $1$ it would have to hold then that $v'(s'(\psi_2\substitute{y}{y'})) = 1$. There needs to be a valuation with restriction to $D_y$ equal to $v_{D_y}$ such that it evaluates $s'(\psi_2\substitute{y}{y'})$ to $0$, otherwise we could set $s(y)(v_{D_y})$ to $s'(y')(v_{D_y})$. For simplicity, assume that $v$ is such a valuation, therefore $v(s'(\psi_2\substitute{y}{y'})) = 0$. This means that we can create valuation $v''$ where we set variables from $s'(\psi_1)$ to the same value as $v$ and variables from $s'(\psi_2\substitute{y}{y'})$ to the same value as $v'$ (others do not matter). This is possible because variables occurring both in $s'(\psi_1)$ and $s'(\psi_2\substitute{y}{y'})$ are only those that are in $D_y$ (see the beginning of the proof) and $v_{D_y} = v_{D_y}'$. However, in this valuation it holds that $v''(s'(\psi_1)) = v''(s'(\psi_2\substitute{y}{y'})) = 0$ which means that $v''(s'(\phi')) = 0$ which is contradiction .... with what... this is not true, it does not have to be equal to 1, it is only subformula......
\end{proof}

%\begin{remark}
%  The condition .... basically means that the set of universal variables occurring both in $\psi_1$ and $\psi_2$ are those from $D_y$ and for existential variable $y''$ to occur in both of them it needs to hold that $D_{y''} \subseteq D_{y}$.
%\end{remark}

\subsection{Quantifier Elimination}
In this section we show haw we can eliminate both universal and existential quantifiers. Firstly, we show that for a simple case where the quantified variable is not in the formula, we can just remove it.

\begin{lemma}
Let $\psi_1 \in \DQBF{V}$. Then
\begin{align}
    \forall x \itholds \psi_1 &\approx \psi_1^{-x} \text{, if } x \not\in \vars{\psi_1}\tag{i}\label{elim:univ}\\
    \exists y(D_y) \itholds \psi_1^{-y} &\approx \psi_1^{-y} \text{, if } y \not\in \vars{\psi_1}.\tag{j}\label{elim:exist}
\end{align}
Let $\psi \in \DQBF{V}$ such that the left side of one of the previous equisatisfiabilities is its subformula. Then $\psi \approx \psi'$ where $\psi'$ results from $\psi$ by replacing this subformula with the equisatisfiable right side.
\end{lemma}
\begin{proof}
  We show the general case $\psi \approx \psi'$ for both equisatisfiabilities.
  
  \eqref{elim:univ} Again, we want to prove $\seman{\psi} = \seman{\psi'}$. For $s \in \seman{\psi'}$ it is obvious that also $s \in \seman{\psi}$. For $s \in \seman{\psi}$ we can create $s'$ where $s'(y) = s(y)\substitute{x}{0}$ where $s(y)\substitute{x}{0}$ is a boolean function which can be represented by a BF that represents $s(y)$ with $x$ substituted by $0$. Then $s' \in \seman{\psi'}$ because for each valuation $v \in \valtns{\uvars{\psi}}$, $v(x) = 0$, we have $v(s'(\psi')) = v(s(\psi)) = 1$.
  
  \eqref{elim:exist} Stems from the fact that $s(\psi) = s(\psi')$ for any $s \in \Scands{\psi}$.
\end{proof}

The next theorem shows how to eliminate universal quantifiers generally by universal expansion. This can be always applied to any universal quantifier but by doing so the resulting DQBF can contain new copies of existential variables. The theorem is based on universal expansion for DQBFs in PNF~\cite{HQSsimpleAlg,NegationOfDQBFs}, here we generalise it to the case of subformulas in DQBFs in NNF.

\begin{theorem}[Universal Expansion]
\label{thrm:unExpan}
  Let $\psi, \psi_1 \in \DQBF{V}$ such that $\forall x \itholds \psi_1$ is a subformula of $\psi$ where $\psi_1$ does not include any quantifications other than the ones bounded to variables from the set $E_{x} = \set{y \in \evars{\psi_1} | x \in D_y}$ of all existential variables dependent on $x$. Let $\psi_2$ be a DQBF that results from $\psi_1$ by substituting each $y \in E_x$ with a new variable $y' \not\in V_{\psi}$ where we set $D_{y'} = D_y$. Then $\psi \approx \psi'$ where $\psi'$ results from $\psi$ by replacing the subformula $\forall x \itholds \psi_1$ by 
  \[\xi = (\psi_1^{-x}\substitute{x}{0} \land \psi_2^{-x}\substitute{x}{1}).\]
\end{theorem}
\begin{proof}
  First notice that each $y \in E_x$ must be entirely inside $\psi_1$ (even the ''$\exists y$'' bit). This stems from the way the set $\DQBF{V}$ is constructed; the dependency sets of new existential variables can only be formed from free or completely new variables and if ''$\exists y$'' was outside $\forall x \itholds \psi_1$, then $x \in D_y$ would have to be a free or new variable. Also, because of the assumption that only quantifiers bounded to existential variables from $E_x$
  are in $\psi_1$ it is obvious that $\psi' \in \DQBF{V}$. With that we can now prove that $\seman{\psi} \not= \emptyset$ iff $\seman{\psi'} \not= \emptyset$.
  
  First we prove that if $\seman{\psi} \not= \emptyset$, then $\seman{\psi'} \not= \emptyset$. Let $s \in \seman{\psi}$. We build a satisfying Skolem functions mapping $s'$ of $\psi'$. For all $y \in (\evars{\psi} \setminus E_x)$ set $s'(y) = s(y)$. For $y \in E_x$ and its copy $y' \in \evars{\psi_2}$ we set $s'(y) = s_{x=0}(y)$ and $s'(y') = s_{x=1}(y)$ where $s_{x=0}(y)$ and $s_{x=1}(y)$ denote Boolean functions that behave like $s(y)$ where $x$ is set to $0$ or $1$ respectively. Then $s'$ is a Skolem functions mapping of $\psi'$. To make it satisfying, we have to prove that BF $s'(\psi')$ is true in all valuations over $\uvars{\psi'}$. Notice that $\uvars{\psi'} = \uvars{\psi} \setminus \set{x}$. Let $v$ be one such valuation and denote $v_{x\mapsto0}$ and $v_{x\mapsto1}$ valuations over $\uvars{\psi}$ such that $v(x') = v_{x\mapsto0}(x') = v_{x\mapsto1}(x')$ for $x' \in \uvars{\psi'}$, $v_{x\mapsto0}(x) = 0$ and $v_{x\mapsto1}(x) = 1$. Notice, that $v_{x\mapsto0}(s(\forall x\itholds\psi_1)) = v(s'(\psi_1^{-x}\substitute{x}{0}))$ and $v_{x\mapsto1}(s(\forall x\itholds\psi_1)) = v(s'(\psi_2^{-x}\substitute{x}{1})$. Therefore, if $v_{x\mapsto0}(s(\forall x\itholds\psi_1)) = v_{x\mapsto1}(s(\forall x\itholds\psi_1)) = \kappa$, $\kappa \in \set{0,1}$, then $v(s'(\xi)) = \kappa$. If $v_{x\mapsto0}(s(\forall x\itholds\psi_1)) \not= v_{x\mapsto1}(s(\forall x\itholds\psi_1))$ then $v(s'(\xi)) = 0$ where either $v_{x\mapsto0}(s(\forall x\itholds\psi_1)) = 0$ or $v_{x\mapsto1}(s(\forall x\itholds\psi_1)) = 0$. This means that $v(s'(\xi))$ is equal to $v_{x\mapsto0}(s(\forall x\itholds\psi_1))$ or $v_{x\mapsto1}(s(\forall x\itholds\psi_1))$. Also, because $s \in \seman{\psi}$, it has to hold that $v_{x\mapsto0}(s(\psi)) = v_{x\mapsto1}(s(\psi)) = 1$. Furthermore, the only difference in $s(\psi)$ and $s(\psi')$ are the subformulas $s(\forall x\itholds\psi_1)$ and $s'(\xi)$. This all means that $v(s'(\psi')) = 1$.

  Now we prove the other direction. Let $s' \in \seman{\psi'}$. We build a satisfying Skolem functions mapping $s$ of $\psi$. For all $y \in (\evars{\psi} \setminus E_x)$ we set $s(y) = s'(y)$. For $y \in E_x$ with a copy $y' \in \evars{\psi_2}$ we set $s(y)$ to Boolean function that is represented by BF $((\neg x \land s'(y)) \lor (x \land s'(y')))$ where $s'(y)$ and $s'(y')$ are replaced with BFs representing them. It is obviously a Skolem functions mapping, thus we need to prove that $s(\psi)$ is true in all valuations. Let $v$ be a valuation over $\uvars{\psi}$. Without loss of generality assume that $v(x) = 0$. Then $v(s(y)) = v(s'(y))$. This means that $v(s(\forall x \itholds \psi_1)) = v(s(\psi_1^{-x}\substitute{x}{0}))$. Again we show that $v(s(\psi)) = 1$ from the facts that $v(s'(\psi')) = 1$ (because $s' \in \seman{\psi'}$) and that the only difference in $s(\psi)$ and $s(\psi')$ are the subformulas $s(\forall x\itholds\psi_1)$ and $s'(\xi)$. If $v(s'(\xi)) = 1$ then $v(s(\forall x \itholds \psi_1)) = v(s'(\psi_1^{-x}\substitute{x}{0}) = 1$ and from the previous facts it means that $v(s(\psi)) = 1$. For the case when $v(s'(\xi)) = 0$ we have to realise that because $\psi'$ is in NNF, $s'(\xi)$ occurs in $s'(\psi')$ in a tree of ${\land}$ and ${\lor}$ operations. That means that even if we replaced $s'(\xi)$ with $s(\forall x \itholds \psi_1)$ and $v(s(\forall x \itholds \psi_1)) = 1$, this cannot change the value of the reulting formula $v(s(\psi))$ from $1$ to $0$, therefore $v(s(\psi)) = 1$.
\end{proof}
\begin{example}
Let $\psi$ be the DQBF from Example~\ref{ex:DQBF:NNF}. Using universal expansion we can transform it to
\begin{multline*}
    \psi' = \forall x_1 \itholds ((x_1 \lequal 0) \lor \exists y (\emptyset) \neg(x_1 \lequal y)) \land {}\\
    ((x_1 \lequal 1) \lor \exists y' (\emptyset)\itholds\neg(x_1 \lequal y'))
\end{multline*}
which (like $\psi$) is satisfiable.
\end{example}

The conditions when existential elimination is possible are more strict:

\begin{theorem}[{\cite[Theorem 5]{HQSquantifierLocalization}}]
\label{thrm:exElim}
  Let $\psi, \psi_1 \in \DQBF{V}$ such that $\exists y(D_y)\itholds\psi_1$ is a subformula of $\psi$ where $\psi_1$ does not include any quantification and includes only variables from $D_y \cup \fvars{\psi} \cup \set{y' \in \evars{\psi} | D_y' \subseteq D_y}$. Then $\psi \approx \psi'$ where $\psi'$ results from $\psi$ by replacing the subformula $\exists y(D_y)\itholds\psi_1$ by \[(\psi_1\substitute{y}{0} \lor \psi_1\substitute{y}{1})\].
\end{theorem}
%The conditition ... is there so that the replaced subformula stays a proper DQBF.
\begin{example}
Let
\begin{multline*}
\psi = \forall x_1 \forall x_2 \exists y_1(x_1) \itholds (((x_1 \land x_2) \lequal y_1) \lor {} \\
\exists y_2 (x_1,x_2) \itholds ((x_1 \lequal y_2) \land (y_1 \lequal y_2)))
\end{multline*}
be a DQBF that says that either $y_1$ has the same value as $x_1 \land x_2$ (which is impossible because $y_1$ depends only on $x_1$) or there is some $y_2$ which is equal to both $y_1$ and $x_1$ (which is possible because both $y_1$ and $y_2$ depend on $x_1$). This means that this formula is satisfiable. Because the subformula $\exists y_2 (x_1,x_2) \itholds (x_1 \lequal y_2) \land (y_1 \lequal y_2)$ fulfills the conditions from the theorem, $\psi$ can be transformed to
\begin{multline*}
\psi = \forall x_1 \forall x_2 \exists y_1(x_1) \itholds (((x_1 \land x_2) \lequal y_1) \lor {}\\
(((x_1 \lequal 0) \land (y_1 \lequal 0)) \lor ((x_1 \lequal 1) \land (y_1 \lequal 1))))
\end{multline*}
which is still satisfiable.
\end{example}



\section{Binary Decision Diagrams}
%Having defined DQBFs we can now turn our attention to their representation. We have already defined some normal forms in section blabla, but algorithmically, working with them in this form would not be very effective (why?). For this reason binary decision diagrams (BDDs) were introduced~\cite{BDD}. These structures allow for a succinct representation of BFs with an efficient polynomial time implementation of logical operations.
In this section we recall a definition of \emph{binary decision diagrams}~\cite{BDD} which is a succinct representation of BFs with an efficient polynomial time implementation of logical operations.

\begin{definition}
  Let $V$ be a set of variables. A \emph{binary decision diagram} (BDD) \emph{over $V$} is a rooted directed acyclic graph with two terminal nodes 0 and 1 and a set $N$ of non-terminal nodes, each representing a variable from $V$. Each $n \in N$ has two child nodes, low child and high child. For each $x \in V$ and every path $\sigma$ from root to a terminal node there is at most one $n \in N$ on $\sigma$ representing $x$.
\end{definition}

%We will give a definition of reduced ordered binary decision diagram, however we do not use that name and whenever we say BDD we mean ROBDD.

Let $v\colon V \to \{0,1\}$ be a valuation over $V$. BDD $\beta$ in this valuation is evaluated to 0 or 1 by starting in the root and for every $n \in N$, representing some $x \in V$, either moving to low child if $v(x) = 0$ or to high child if $v(x) = 1$. The resulting terminal node is then the evaluation $v(\beta)$ of $\beta$ in $v$. BDD $\beta$ then represents a Boolean formula $\phi \in \BF{V}$ if for each valuation $v$ it holds that $v(\beta) = v(\phi)$.

In figures, non-terminal nodes are denoted by the variable they represent, terminal nodes are shown as boxes with the constant they represent, edges to low children are dashed and edges to high children are full.

\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \includegraphics{figures/bdd1.pdf}
        \caption{BDD}
        \label{fig:BDD}
    \end{subfigure}%
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \includegraphics{figures/bdd2.pdf}
        \caption{ROBDD}
        \label{fig:ROBDD}
    \end{subfigure}
    %\subcaptionbox{\label{fig:BDD}BDD}
    %    {\includegraphics{figures/bdd1.pdf}}
    %\subcaptionbox{\label{fig:ROBDD}ROBDD}
    %    {\includegraphics{figures/bdd2.pdf}}
    \caption{An example of BDD and ROBDD that represent the same BF $(\neg x_1 \land x_2 \land x_3) \lor (x_1 \land \neg (x_1 \lequal x_2))$}
    \label{fig:BDDandROBDD}
\end{figure}

\begin{example}
\label{ex:BDD}
Figure~\ref{fig:BDD} shows an example of a BDD representing the BF $(\neg x_1 \land x_2 \land x_3) \lor (x_1 \land \neg (x_1 \lequal x_2))$. 
\end{example}

To have simpler algorithms for BDDs, we actually use \emph{reduced ordered BDDs} (ROBDDs) which are BDDs such that 
\begin{enumerate}
    \item the variables on each path from the root of BDD to a terminal node are in the same order (possibly some of them are missing),
    \item the isomorphic (''the same looking'') subtrees are merged and
    \item nodes whose both edges go to the same subtree are deleted.
\end{enumerate}
They have the nice property that for a given variable order, each BF is represented by exactly one ROBDD. In the following chapters, when we use BDD we mean ROBDD.

\begin{example}
\label{ex:ROBDD}
Figure~\ref{fig:ROBDD} shows a ROBDD which represents the same BF as the BDD from Example~\ref{ex:BDD}. While the BDD from Figure~\ref{fig:BDD} does not have ordered variables the ROBDD always goes from root to terminal node with $x_1$ followed by $x_2$ and $x_3$. Also, one $x_3$ node was deleted because both edges coming from it ended in $0$. Furthermore, both $x_2$ nodes share an isomorphic subtree.
\end{example}

%To have simpler algorithms for BDDs, we usually want to have some ordering on the set of variables $V$ such that for each path from the root of BDD to the terminal of the BDD has nodes in this order. These BDDs are called ordered BDDs (OBDDs). The ordering of BDDs is important, because two BDD representations of the same BF in different orderings can have very different sizes. odkazat sa na obrazok ze tam je ordered 

%Two OBDDs with the same ordering representing the same BF can still be different, that is why we will actually work with reduced OBDDs (ROBDDs) which is an OBDD that merges isomorphic (''the same looking'') subtrees and deletes nodes whose both edges go to the same subtree. 

%As a final step 

% chceme mat linearne operacie ---> treba aby boli usporiadane ---> shannon expansion ---> ukazat operacie???
%When we have two BDDs, we want to have an effective way to compute their conjunction/disjunction. Such an algorithm should just traverse the BDDs in the same way while comparing the variables in the nodes. However, variables in the nodes on the paths from the root in general BDDs can occur in any order, which would cause problems with simple traversal of BDDs. To solve this we add an ordering on the set of variables $V$. The nodes in the BDD are then sorted based on this ordering. The resulting BDD is called an ordered binary decision diagram (OBDD).

%\begin{example}
%ukazat asi z previous example 2 orderings a povedat daco o tom ze operacie sa daju teraz implementovat jednoducho len prechadzanim stromom
%\end{example}

%nieco o ROBDD, ze pre kazde BF existuje prave jedno unikatne pre kazde zoradenie + ze vyber zoradenia je dolezity + ze da sa dynamicky preukladat???
%OBDDs still suffer from one problem -- for each BF we would like to have for given order on $V$ only one OBDD representing it. This is not the case, notice OBDDs on fig. ????? and ???. Both represents BF ??? but they are different. That is why we introduce reduced OBDDs (ROBDD) (vysvetlit lepsie ze to neni moj prinos). ROBDD is an OBDD such that all isomorphic sub-BDDs are merged and the nodes that have the same BDD as children are removed.

%\begin{example}
%porovnat nejake OBDD s jeho ROBDD, detailne (kde sa ukaze )
%\end{example}

For each operation on BFs (${\land}$, ${\lor}$, ${\neg}$), there is an algorithm on BDDs which can get the resulting BDD representing the application of the operation. For example, if we have a BDD representing BF $\psi_1$, we can get a BDD representing $\neg \psi_1$ by swapping terminal nodes $0$ and $1$. See for example Andersen~\cite{BDDdetails} for more details. %If we have another BDD representing BF $\phi_2$, we can get $\psi_1 \land \psi_2$ by using this algorithm.  Similarly an algorithm for ${\lor}$ can be defined.

%In the following we will use the term BDD instead of ROBDD.


\section{Quantifier Trees}


% TODO, define l(n) which assign either operation or literal
\newcommand{\qtlabel}[1]{l({#1})}
% TODO, define \evars{n},\uvars{n} where n is a node as the set of all existential variables such that it is an existential variable of DQBF formula that is represented by tree rooted in n (we assume this tree is proper tree that can represent some formula) ---- problem: nebude fungovat v algoritme, lebo subtree nevie o prefixoch v ancestors... mozno zadefinovat len V_{n} ako mnozinu variables nachadzaujich sa v tom tree???? a zadefinovat si mnoziny existential a universal variables v prefixoch???? aaalebo zadefinuj to ako pre cely strom, teda budeme to brat ako subformulu ale bereme exist/univ variables z \evars{\psi}/\uvars{\psi} kde \psi je formula ktoru reprezentuje root r
% TODO, define Q(n) as the quantifier prefix assignment and say that we abuse notation and use it also as the set of variables in the quantifier prefix 
\newcommand{\prefix}[1]{Q({#1})}
\newcommand{\eprefix}[1]{Q_{\exists}(#1)}
\newcommand{\uprefix}[1]{Q_{\forall}(#1)}
% TODO, define children(n) as the set of children of node n
\newcommand{\children}[1]{children({#1})}

While BDDs are a good represantion of BFs, we also need a represenation for DQBFs. For this we define \emph{quantifier trees} which can represent DQBFs in NNF.

\begin{definition}
  Let $V$ be a set of variables. A \emph{quantifier tree} \emph{over $V$} is a rooted directed tree with labelling $l$ which assigns to each non-terminal node an operation ${\diamond} \in \set{{\land},{\lor}}$ and to each terminal node a literal from $V$ (a variable $v \in V$ or its negation), and a prefix mapping $Q$ which maps to each node some DQBF prefix.
\end{definition}

A quantifier tree with root $r$ represents a DQBF formula where children of the node $r$ are subformulas connected with the operation $\qtlabel{r}$ (or if $\qtlabel{r}$ is a literal it represents this literal) with quantifier prefix $\prefix{r}$. However, not each quantifier tree represents a proper DQBF formula, we restrict ourselves only to the set of quantifier trees which represent some formula.

%TODO change in algorithm to \vars{n} everywhere because \evars{n}/\uvars{n} have differnet meaning
We denote the set of children of node $n$ as $\children{n}$. We also abuse notation and use $\prefix{n}$ as a set of variables which are in this quantifier prefix. somethingsomething $\eprefix{n}$ is set of existential variable in $\prefix{n}$someting soemign We use $\vars{n}, \evars{n}$ and $\uvars{n}$  TODO

Each DQBF in NNF can be represented by a quantifier tree by starting from literals and recursively creating subtrees for each operation. 

In figures, the assigned DQBF prefix to non-terminal node $n$ is always shown on the edge coming to the node $n$, while the nodes are labelled either by the assigned operation or literal (see Figure~\ref{fig:QTex}). For the root, we add an extra ``edge'', just to show the quantifier prefix before the whole formula.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>={Stealth[scale=1.3,angle'=90]},node distance=2cm,initial distance=1.3cm,initial text=$\forall x_1 \exists y_1(x_1) $,every state/.style={minimum size=0pt}]
    \node[state,initial above] (1) {${\land}$};
    \node[state, below of=1] (2) {$x_1$};
    \node[state, left of=2] (3) {${\lor}$};
    \node[state, right of=2] (4) {${\lor}$};
    \node[state, below right = 1.3cm and 0.4 cm of 4,inner sep=1pt] (5) {$\neg y_1$};
    \node[state, below left = 1.3cm and 0.4 cm of 4] (6) {$x_2$};
    \node[state, below right = 1.3cm and 0.4cm of 3,inner sep=1pt] (7) {$\neg x_1$};
    \node[state, below left = 1.3cm and 0.4cm of 3] (8) {$y_2$};
    
    \draw (1) edge[right] node{$\forall x_2$} (4)
          (1) edge[left] node{$\exists y_2(\emptyset)$} (3)
          (1) edge (2)
          (3) edge (7)
          (3) edge (8)
          (4) edge (5)
          (4) edge (6)
          ;
    \end{tikzpicture}
    \caption{An example of quantifier tree}
    \label{fig:QTex}
\end{figure}

\begin{example}
  Figure~\ref{fig:QTex} shows an example of quantifier tree representing DQBF \[\forall x_1 \exists y_1(x_1) (\exists y_2(\emptyset) \itholds (y_2 \lor \neg x_1) \land x_1 \land \forall x_2 \itholds (x_2 \lor \neg y_1)).\]
\end{example}

%TODO povedat ze operacie sa striedaju, nemoze nastat ze child ma rovnaku operaciu ako parent a vysvetlit ze je to len cisto aby boli algoritmy efektivnejsie??

\chapter{State of the Art}
In this chapter we give an overview of existing solutions and solvers which tackle the satisfiability problem of DQBF. Because there are already multiple surveys about DQBF~\cite{DQBFStateOfArtTalk,DQBFStateOfArt,DQBFStateOfArtNew}, we give only a short overview of most solvers and techniques. However, we go into more details for solver HQS, because it is currently the best performing solver (winner of the DQBF track of QBF Evaluation 2018~\cite{QBFeval18} and 2019~\cite{QBFeval19}) and the methods we use for developing our solver are based on the workings of this solver.

%\section{The Problem of Satisfiability}
%Let $\psi$ be DQBF. The problem we are trying to solve is to tell whether this formula is satisfiable, that is if there exists model in which it is true. For BF, this problem belongs to NP-complete class of problems cite. If we move to QBF, the problem gets harder and belongs to PSPACE-complete class. As was shown in CITE, this problem for DQBF belongs in NEXPTIME-complete class of problems, that is it is even harder.

\section{First Solution -- DQDPLL}
The first solver that tackled the satisfiability problem for DQBF was based on DPLL~\cite{DPLL} algorithm which is successfully used for BF and QBF solvers. This algorithm works on formulas in CNF by searching for a satisfying assignment based on the clauses in CNF. By recursively choosing an assignment for literals and checking whether the remaining formula in CNF contains an empty clause (which implies unsatisfiability), DPLL searches trough all assignments until a satisfying one is found or all of them are decided to be unsatisfying. An adaptation called DQDPLL~\cite{DPLLalgorithm} was introduced for DQBF (in PCNF) which extended existing solutions for QBF by adding so-called Skolem clauses which encode the dependencies between existential and universal variables. However, by doing so the algorithm becomes too slow and results in an uncompetitive solver.

\section{Instantiation -- iDQ and iProver}
The first efficient DQBF solver, called iDQ~\cite{iDQandDQDIMACS}, is based on an instantiation technique used for solving Effectively Propositional Logic (EPR)~\cite{iProver}. This solver also works only on formulas in PCNF where in each step of the algorithm it tries to create a BF $\phi$ that is an overapproximation of an input DQBF. This is done by instantiating some set of clauses, that is it applies universal expansion locally to them. This BF $\phi$ is then checked for satisfiability, where if $\phi$ is unsatisfiable then the input DQBF is also not satisfiable, while if it is satisfiable, it must be checked if the resulting valuation is valid for the input DQBF. If it is not, then it is used to create more clause instances which are then used to refine this overapproximation.

Furthermore, a solver for EPR can also be used directly for DQBF. Because EPR belongs to the same complexity class as DQBF, there exists a polynomial-time reduction from DQBF to EPR~\cite{iDQandDQDIMACS}. This is used by EPR solver iProver~\cite{iProver} which transforms a DQBF in PCNF to an EPR instance and then solves this. %The results from QBF Evaluation 2018~\cite{QBFeval18} shows that iProver is more efficient than iDQ.  %In the SAT competition??? it turned out that iProver is more powerful compared to iDQ??

\section{Clausal Abstraction -- dCAQE}
Another DQBF solver called dCAQE~\cite{dCAQE} is based on clausal abstraction~\cite{ClausalAbstr}. This solver --- working again on DQBF in PCNF --- first puts universally and existentially quantified variables to some sets (called nodes) which are then divided into levels based on the ordering of dependencies of existential variables. The algorithm then constructs for each node on each level a BF that represents which clauses in CNF it can satisfy (for existential node) or falsify (for universal node). The algorithm then builds a candidate valuation by processing each level. For each level either this valuation is extended, or there is some conflict which means that the algorithm has to backtrack to some lower level and refine the abstraction, or the candidate valuation is a satisfying one which ends the algorithm.

%mozno spomenut fork splitting or something like that, v arXiv rozsirenej verzii maju nieco o tom v appendixe

\section{Quantifier Elimination -- HQS}
The next solver is based on quantifier elimination. This solver's basic premise is simple --- it iteratively chooses some universal variable for universal expansion (Theorem~\ref{thrm:unExpan}) thus eliminating it and then eliminates all existential quantifiers that are dependent on all leftover universal quantifiers using Theroem~\ref{thrm:exElim}.

\begin{algorithm}
\caption{Quantifier elimination algorithm}
\label{alg:QE}
\begin{algorithmic}[1]
\Function{SolveDQBF}{DQBF $\psi$ in PCNF}
\While{$\uvars{\psi}$ is not empty}%there is some universal variable $x$ in $\psi$
    \State choose and remove $x$ from $\uvars{\psi}$
    \State $\psi = \forall\text{-expansion}(x,\psi)$% universal expansion
    \ForAll{$y \in \evars{\psi}$ s. t. $D_y = \uvars{\psi}$} %existential variables $y$ such that they depend on all universal variables in $\psi$
        \State $\psi = \exists\text{-elimination}(y,\psi)$% existential expansion
        \State remove $y$ from $\evars{\psi}$
    \EndFor
\EndWhile
\State return SAT($\psi$)
\EndFunction
\end{algorithmic}
\end{algorithm}

Gitina et al.~\cite{HQSsimpleAlg} introduced the basic algorithm for solving DQBF in PCNF in this way. %(mozno spomenut ze to vlastne vymysleli aj v iDQ clanku, ako nejaky base solver ktory pouziva BDDcka) 
Algorithm~\ref{alg:QE} shows simple pseudocode of this. In every step, this algorithm chooses (using some heuristic) an universal variable to eliminate. The authors used a heuristic where the universal variable is chosen based on the number of existential ones that depend on it --- they choose the one that has minimal number of dependencies. After that, all the existential variables that depend on everything are also eliminated. To use this algorithm it is important to choose a good representation of the matrix of the DQBF. For this the authors chose and-inverter graphs~\cite{FRAIGs}. % (AIG) which are tree-like structures where non-terminal nodes represent conjunction, terminal nodes are variables and these are connected with two types of nodes: normal ones and those that represent negation. With a proper implementation of operations they can be optimised in such a way that they reuse parts of the graphs resulting in functionally reduced AIGs~\cite{FRAIGs}.

Following this technique, solver HQS was introduced~\cite{HQSquantifierElimination} which was enhanced by using QBF solver as a subprocedure. They still eliminate quantifiers in similar fashion but now they do it until the formula can be transformed to QBF (that is the dependency sets are linearly ordered). On this QBF they then run already existing solver for QBF called AIGSolve~\cite{AIGSolve} which can use more effective techniques developed for QBFs. Universal quantifiers to eliminate are chosen in the beginning in such a way that the number of universal eliminations is as small as possible while still the resulting formula is QBF. For this they build a dependency graph in which nodes are existential variables where $y_i$ is connected to $y_j$ if for their dependency sets it hold that $D_{y_i} \not\subseteq D_{y_j}$. They noticed that if this graph is acyclic, the formula can be seen as QBF. Furthermore, there is a cycle in this graph iff there is a simple cycle (between two nodes) in the graph. They use this to create an instance of MaxSAT problem which is a problem of finding a valuation of one BF while maximizing another formula. This instance then encodes which universal variables have to be eliminated so the dependency graph becomes acyclic while minimising the number of universal variables to eliminate. After finding the set of variables to eliminate, they follow with an improved quantifier elimination algorithm. They also improved it by adding a preprocessing step (see Section~\ref{sec:preprocessing}) and elimination of special types of variables called unit and pure. 

The algorithm was changed a bit again by Wimmer et al.~\cite{HQSdependencyElimination}. The authors were interested in whether it is possible to somehow remove specific dependencies from the list of dependencies of existential variable. They have shown that it is possible, albeit at the expense of adding a new existential variable. This is similar to the universal expansion (Theroem~\ref{thrm:unExpan}), but by removing just one dependency we add just one new existential variable. Let for example
\[\psi = \forall x_1 \dots \forall x_n \exists y_1(D_{y_1}) \dots \exists y_m(D_{y_m}) \itholds \phi\]
be a prenex DQBF where $\phi$ is a BF and $x_1 \in D_{y_1}$. We can now remove $x_1$ from $D_{y_1}$ by adding a copy of $y_1$ resulting in an equisatisfiable DQBF
\begin{multline*}
\forall x_1 \dots \forall x_n \exists y_1^0(D_{y_1} \setminus \{x_1\}) \exists y_1^1(D_{y_1} \setminus \{x_1\}) \exists y_2(D_{y_2})\dots \exists y_m(D_{y_m}) \\
\phi\left[((\neg x_1 \land y_1^0) \lor (x_1 \land y_1^1))/y_1\right].
\end{multline*}
Using this the authors do not look for a set of universal variables to eliminate, but for partial dependencies whose removal will result in a DQBF which can be transformed into QBF. Again, they create a dependency graph which is acyclic iff DQBF can be seen as QBF. But now they create a bipartite graph whose two sets of nodes are the set of universal variables and the set of existential variables which are connected based on whether universal variable is in the dependency set of existential one. Similarly to previous, they use this graph to solve an optimization problem that encodes which dependencies to remove to get QBF which can then be solved with AIGSolve.

Last but not least, Ge-Ernst et al.~\cite{HQSquantifierLocalization} have given a theoretical foundations for non-prenex DQBFs and the possibility to push and eliminate quantifiers inside formulas as explained in Section~\ref{sec:quantLocalization}. Using this they improve HQS by adding another step in the algorithm, where they first push quantifiers as much as possible into the formula, eliminate the existential variables using Theorem~\ref{thrm:exElim} and then return the formula back to the prenex form. After this they start with the elimination of universal quantifiers as was explained in previous paragraphs.

\section{Preprocessing}
\label{sec:preprocessing}
In previous sections, we give an overview of techniques used for implementations of different solvers. This sections explains some techniques that are used before the actual solvers run, called fittingly preprocessing.

\subsection{HQSpre}
\label{sec:HQSpre}
The first and only preprocessing engine for DQBF called HQSpre~\cite{HQSpre1,HQSpre2,HQSpreJournal} took many techniques used for QBF preprocessing and lifted them to the DQBF case. We explain only one technique here, called \emph{gate extraction}. As was mentioned in Section~\ref{sec:BF:CNF}, transforming BF to an equisatisfiable formula in CNF can result in polynomial increase of the size of the formula by adding new variables. Gate extraction works in opposite direction --- it tries to extract this newly introduced variables and turn the formula back into one that is not in CNF. This does not mean that gate extraction works only on formulas in CNF, it can be used generally by finding connections between variables which make it possible to replace a variable by some Boolean function of existing variables. However, this technique can only be used by solvers which can work on DQBFs which are not in PCNF. Currently, that is only HQS. For a thorough explanation of other techniques used by HQSpre we refer the reader to the work by Wimmer et al.~\cite{HQSpreJournal}. 

\subsection{Approximations}
Another technique which is used in some solvers as preprocessing step is to find some BF or QBF approximations which can be used with existing solvers for BFs/QBFs to potentially give us faster result about the input DQBF (satisfiability for underapproximations, unsatisfiability for overapproximations). Gitina et al.~\cite{HQSsimpleAlg} introduced QBF approximations which are created by changing the dependencies of existential variables that result in QBF with the same matrix. However, these approximations can be precise only up to some level. By adding some information to these QBF overapproximation (thus changing the matrix), Finkenbeiner et al.~\cite{FastDQBFRefutation} were able to create more and more precise QBF overapproximations. For more thorough explanation of these approximations see again the work by Wimmer et al.~\cite[Section~3]{HQSpreJournal}.

\subsection{\texorpdfstring{$\PSPACE$}{PSPACE} subclass}
The last preprocessing technique is simply put just a check whether DQBF does not belong to a subclass of problems which are in $\PSPACE$ and if it does, it is transformed to QBF (which is $\PSPACE$-complete) on which existing QBF solver is run. The simplest such subclass would be those DQBFs whose dependencies are linearly ordered. Then it can be easily transformed into QBF by reordering the quantifiers. Scholl et al.~\cite{PSPACEsubclass} investigated whether there is some another DQBF subclass which is in $\PSPACE$. They show that DQBFs where the dependency sets are either equal or pairwise disjoint can be transformed into QBFs with just linear increase in size. Thus having a check on whether an input DQBF belongs to this class before running a DQBF solver and if it does transforming it into QBF and running a QBF solver can improve the efficiency. They show this by adding this preprocessing step to HQS which results in increase of solved instances.

%As a note toto vzislo z toho, ze clanok zrobil dajaky system ktory je rozsirenie QBF systemu kde pridali fork extension pravidlo. They showed that this system is complete and sound for DQBF, however, in dCAQEclanok (ale v appendixe extended version) and PSPACEclanok ukazali ze to tak nie je (nie je complete ci co). Obe tieto clanky ukazali ze tento system je complete pre tuto PSPACE classu. Zaroven dCAQE vyuziva tento fork extension ???a zle si myslia ze tato classa je NEXPTIME??? vo svojom algoritme, takze je moznost ze ich algoritmus nefunguje pre celu classu DQBF

\chapter{Suggested Algorithm}
\label{chap:algorithm}
%TODO: decide the name, our/suggested/new/... algorithm

In this chaoter we introdice the ??suggested?? algorithm for solving satisfiability of DQBF using BDDs. First we give a high level eplanation of the algorithm and then we explain each part of it showing different heuristics for solving it???

\section{High level defintion???}
\begin{algorithm}
  \caption{???}
  \label{alg:general}
  \begin{algorithmic}[1]
    \Function{SolveDQBF}{DQBF formula $\psi$ represented as quantifier tree with root $r$}
    \State \Call{Localise}{$r$}
    \State $\phi$ = \Call{TurnToBDD}{$r$}
    \State \Call{EliminateAllQuantifiers}{$r$, $\phi$} \label{alg:general:elimination}
    \If{$\phi = 0$}
      \State \Return UNSAT
    \Else
      \State \Return SAT
     \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

The algorithm is shown in .... is a high level definition of out algorithm. In the next sections we explain more thoroughly each part of the algorithm. It takes as an input a DQBF $\psi$ in NNF represented using quantifier tree. First, using some heuristic function localise(????) recursively pushes the quantifiers inside the formula, usually by using rules from Theorem~\ref{thrm:quantLocalEq}. Next, we transform this quantifier tree into a tuple of quantifier prefix and a BF represented by BDD by recursively turning children of each node into this tuple of prefix and BDD and combining them together. something about pulling the quantifiers back??? the quantifiers are pulled back, however, we remove some of them??? During this some quantifiers can be eliminated by using theorems for quantifier eliminations (Theorem~\ref{thrm:unExpan} and \ref{thrm:exElim}), Section??? shows different heuristics how to decide which quantifiers are eliminated. Finally, the leftover quantifiers in the prefix are eliminated resulting in BDD which represents either $0$ or $1$ which tells us whether the formula is satisfiable or not.

%vysvetlit co je to quantifier tree (proste reprezentacia DQBF, kde kazdy non terminal node reprezentuje operaciu and alebo or na children (co su subformule) a pri kazdom tomto node su ulozene kvantifikatory; terminal nodes su literals) -- hodit mozno do kapitoly 1, plus obrazok

%algoritmus zacina s tymto stromom kde vsetky kvantifikatory su v root, pomocou theoremu o lokalizacii ich strcime dnu (popisat heuristiku ze ako ich strkame), potom rekurzivne prechadza tento strom, kde ziska s children formule, z ktorych vytiahne kvantifikatory a maticu prevedie do BDD a potom nejakou heuristikou sa rozhodne ktore kvantifikatory sa odstrania, tie sa odstrania (pouzitim theorems o odstranovani - pridat mazanie ak nie je v support set, nejakou heuristikou sa rozhodne v akom poradi) a return zvysny prefix s maticou v BDD


\section{Localising quantifiers}
% TODO we assume that \fvars{n} is empty and all \qvars{n} are in \prefix{n}
In this section we give a ... of the function \textproc{Localise} from Algorithm~\ref{alg:general} which uses rules from Theorem~\ref{thrm:quantLocalEq} to push quantifiers as deep inside a formula as it is possible. %We use two ...implementations... of this algorithm: one that basically does nothing, which means that after doing \textproc{TurnToPrefixAndBDD}, the resulting quantifier prefix will be the same as the quantifier prefix of the input formula $\psi$ and another that actually pushes quantifier inside. This second ???implementation??? is based on the algorithm which is used for localising quantifiers in the solver HQS~\cite{HQSquantifierLocalization}. However, we update it with the fix for disjunction????
%TODO cely tento algoritmus je based na tom co robia v HQS
%\begin{itemize}
%    \item we do not localise - for simple solver
%    \item when we localise for conjuction and univ/exist quantifier we choose this and this children to put it in etc. for disjunction and univ/exist this and this etc.
%\end{itemize}

\begin{algorithm}
  \caption{Quantifier localisation}
  \label{alg:localise}
  \begin{algorithmic}[1]
    \Function{Localise}{node $n$}
      \If{$\qtlabel{n} = {\land}$}
        \State \Call{LocaliseAND}{n}
      \ElsIf{$\qtlabel{n} = {\lor}$}
        \State \Call{LocaliseOR}{n}
      \EndIf
      \ForAll{$n' \in \children{n}$}
        \State \Call{Localise}{$n'$}
      \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Algirithm~\ref{alg:localise} shows this implementation of localising. Function \textproc{Localise} first, based on the assigned operation to node $n$ either calls \textproc{LocaliseOR} or \textproc{LocaliseAND}. These functions push variables from $\prefix{n}$ to the children of $n$ based on the rules from Theorem~\ref{thrm:quantLocalEq}. After that, the algorithm recursively runs \textproc{Localise} on the children of $n$. Notice, that this algorithm does not do anything for terminal nodes, because for them we cannot push quantifiers anymore.

\begin{algorithm}
  \caption{Quantifier localisation for conjuction}
  \label{alg:localiseand}
  \begin{algorithmic}[1]
    \Function{LocaliseAND}{n}
      \While{$\eprefix{n} \not= \emptyset$}\label{localiseand:existbegin}
        \State $y \gets \Call{GetNextExistVarToPush}{\null}$\label{localiseand:getevar}
        \State $yChildren \gets \set{n' \in \children{n} | y \in \vars{n'}}$\label{localiseand:egetchildren}
        \If{$yChildren = \children{n}$}\label{localiseand:echildtest}%\Comment{$y$ is in every child}
          \State break
        \Else
          \State $n_y \gets \Call{CombineChildren}{yChildren, {\land}}$\label{localiseand:ecombine}
          \State $\children{n} \gets (\children{n} \setminus yChildren) \cup n_y$\label{localiseand:echildrenupdate}
          % TODO, explain that even though we do not rename, the algorithm still work, also explain what pushing means
          \State \Call{PushVar}{$y$, $n_y$}\label{localiseand:epush}
          \State remove $y$ from $\prefix{n}$\label{localiseand:eremove}
        \EndIf
      \EndWhile\label{localiseand:existend}
      %\Statex \(\triangleright\) get all univ vars on which none of the exist vars in quantifier prefix depends
      \State $U \gets \set{x \in \uprefix{n} | x \not\in D_y \text{ for all } y \in \eprefix{n}}$\label{localiseand:upossible}
      \ForAll{$x \in U$}\label{localiseand:univbegin}
        \ForAll{$n' \in \children{n}$}
          \If{$x \in V_{n'}$}
            \State \Call{PushVar}{$x$, $n'$}\label{localiseand:upush}
          \Else
            \State remove $x$ from dependencies of all $y \in \evars{n'}$\label{localiseand:uremovedep}
          \EndIf
        \EndFor
        \State remove $x$ from $\prefix{n}$\label{localiseand:uremove}
      \EndFor\label{localiseand:univend}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

The implementation of \textproc{LocaliseAND} is shown in Algorithm~\ref{alg:localiseand}. We first push existential variables on lines~\ref{localiseand:existbegin}-\ref{localiseand:existend} and then universal on lines~\ref{localiseand:univbegin}-\ref{localiseand:univend}. We do it in this order because according to rule \eqref{loc:bothswap} from Theorem~\ref{thrm:quantLocalEq} we can only push universal variables if there are no existential variables in the prefix that depend on them. By pushing existential quantifiers first, the number of universal variables that we are able to push might increase. Also, according to~\eqref{loc:exswap} and~\eqref{loc:unswap} it does not matter in what order we push variables.

In the part that pushes existential variables, we want to apply the rule~\eqref{loc:exboth} for as many existential variables from $\prefix{n}$ as possible. On line~\ref{localiseand:getevar} we first get the existential variable $y$ to apply the rule on. We choose the one that is in fewest children of $n$ as possible, that is the size of the set $yChildren$ on line~\ref{localiseand:egetchildren} is minimal from all the existential variables from $\prefix{n}$. This is because to apply the rule~\eqref{loc:exboth} we need to combine the children from the set $yChildren$ to create a new child $n_y$ (line~\ref{localiseand:ecombine}) into which it can be pushed (line~\ref{localiseand:epush}). This new child $n_y$ is then a quantifier tree with $l(n_y) = {\land}$, $\prefix{n_y} = \emptyset$ and $children(n_y) = yChildren$. Obviously, the sets of children containing each existential variables are actually computed before the while loop so we can easily find the variable with the minimal set. Also, during the combining of children to a new child, these sets are only updated, not recomputed. The while loop finishes after either all existential variables were pushed inside or we got to a variable that is in every child (line~\ref{localiseand:echildtest}) and therefore it is not possible to push it inside. Also, when we find such a variable, because all other variables have to have the sets $yChildren$ at least as large as the found variable, this means that all remaining variables are also in all children.

After pushing all possible existential variables we can start pushing universal ones using rules \eqref{loc:unconj1} and \eqref{loc:unconj2}. First we find the set $U$ of all universal variables in $\prefix{n}$ such that no leftover existential variable in $\prefix{n}$ depends on them. For all these variables we can then either push them into every child (line~\ref{localiseand:upush}) using rules \eqref{loc:unconj1} or \eqref{loc:unconj2}, or if a child does not contain one of the variables $x$, we can by using rule \eqref{loc:unconj2} delete all dependencies on $x$ from the child (line~\ref{localiseand:uremovedep}). Here, we should sometime create a new variables (from rule \eqref{loc:unconj1}). However, this is not needed%TODO as we will explain in next section???

% TODO add theorem about elimination of variables not in support set
% TODO fix quantifier tree section
% TODO fix theorem about diajunction

%TODO example

\begin{algorithm}
  \caption{Quantifier localisation for disjunction}
  \label{alg:localiseor}
  \begin{algorithmic}[1]
    \Function{LocaliseOR}{n}
      \ForAll{$y \in \prefix{n} \cap \evars{n}$}
        \ForAll{$n' \in \children{n}$}
          \State \Call{PushVar}{$y$, $n'$}
        \EndFor
        \State remove $y$ from $\prefix{n}$
      \EndFor
      \While{$\prefix{n} \cap \uvars{n} \not= \emptyset$}
        \State $x \gets \Call{GetNextUnivVarToPush}{\null}$
        \State $xChildren \gets \set{n' \in \children{n} | x \in \uvars{n'} \text{ or } x \in D_y \text{ where } y \in \evars{n'}}$
        \If{$xChildren = \children{n}$}%\Comment{$x$ or its dependency is in every child}
          \State break
        \Else
          \State $n_x \gets \Call{CombineChildren}{xChildren, {\lor}}$
          \State $\children{n} \gets (\children{n} \setminus xChildren) \cup n_x$
          \State \Call{PushVar}{$x$, $n_x$}
          \State remove $x$ from $\prefix{n}$
        \EndIf
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}



say about pushing here, that we delete immediately if it is not in support set

\section{Turning to BDD}
In this section we give an overview of the function \textproc{TurnToBDD} which as the name suggests turns the matrix of the formula to BDD. During this, local elimination of quantifiers in subformulas can occur, which might result in simpler final result. 

\begin{algorithm}
  \caption{Quantifier tree to BDD}
  \label{alg:turntobdd}
  \begin{algorithmic}[1]
    \Function{TurnToBDD}{node $n$}
      \If{$\qtlabel{n}$ is a literal}
        \State return $\qtlabel{n}$ \label{turntobdd:returnterminal}
      \Else
        %\If{$\qtlabel{n} = {\lor}$}
        %  \State $\psi_n = 0$
        %\Else
        %  \State $\psi_n = 1$
        %\EndIf
        \State $childBDDs = \emptyset$
        \ForAll{$n' \in \children{n}$}
          \State $\phi_{n'} = \Call{TurnToBDD}{n'}$ \label{turntobdd:callforchild}
          \State \Call{EliminateQuantifiers}{$n'$, $\psi_{n'}$} \label{turntobdd:eliminate}
          \State $\prefix{n} = \prefix{n} \cup \prefix{n'}$ \label{turntobdd:pullquantifiers}
          \State $childBDDs = childBDDs \cup \set{\phi_{n'}}$ %\label{}
          %\If{$\qtlabel{n} = {\lor}$}
          %  \State $\psi_n = \psi_n \lor \psi_{n'}$
          %\Else
          %  \State $\psi_n = \psi_n \land \psi_{n'}$
          %\EndIf
        \EndFor
        \State return $\Call{ApplyOperation}{\qtlabel{n}, childBDDs}$ \label{turntobdd:returnnonterminal}
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:turntobdd} shows how this function can be implemented. Based on the type of the node $n$ it decides what to do. For terminal nodes, it just return the BDD representing the literal $\qtlabel{n}$ (line~\ref{turntobdd:returnterminal}). For non-terminal nodes, it calls itself recursively for all children of $n$ (line~\ref{turntobdd:callforchild}), eliminates some variables in it (line~\ref{turntobdd:eliminate}), and finally pulls quantifiers from them (line~\ref{turntobdd:pullquantifiers}). The quantifiers can be pulled from the children based on the rules \eqref{loc:unconj1}, \eqref{loc:undisj}, and \eqref{loc:exboth} of Theorem~\ref{thrm:quantLocalEq}. Also (\ref{loc:unconj1}) is used to rename all the copies which were created by using the same rule during localisation back to the original variable. 
% TODO povedat v implementacii ze duplikaciu nerobim
On line~\ref{turntobdd:returnnonterminal} the algorithm returns the resulting BDD which is the application of the operation $\qtlabel{n}$ on the children BDDs.

For the elimination of the quantifiers on line~\ref{turntobdd:eliminate} we can do these three things:
\begin{itemize}
    \item nothing -- we do not eliminate any variables from the BDD,
    %\item eliminate only those that are not in support set -- useless, it will basically do what nothing does, because we assume that input formula has already only those variables in quantifier prefix which are in support set, just pushing it inside and then taking them out will not delete anyone --- it might delete some dependencies though (but nothing should do same, if we assume that nothing is doing localising)
    \item eliminate only ``simple'' quantifiers -- we eliminate the universal variables using Theorem~\ref{thrm:unExpan} only if they do not create new variables (that is no existential variable depend on them) and all possible existential variables using Theorem~\ref{thrm:exElim} (this elimination technique is used in HQS~\cite{HQSquantifierLocalization}), %we eliminate exist vars (or maybe just some univ. vars - those that only few exist vars depend on (probably 0, maybe 1 or 2) or those that will allow me to remove some exist vars)??? - basically eliminate only when no (a few) new variables are created
    \item eliminate all possible quantifiers -- we iteratively eliminate universal variables using Theorem~\ref{thrm:unExpan} and again all possible existential variables using Theorem~\ref{thrm:exElim}. This is the same elimination as in function \textproc{EliminateAllQuantifiers} on line~\ref{alg:general:elimination} of Algorithm~\ref{alg:general}, see the next section for more details. %remove everything possible (all universal vars and possible exist. vars, in iteration -> one universal var, all possible existential vars (based on theorem~\ref{thrm:exElim}) and so on) - tree solver
    %\item remove some dependencies to be able to remove exist vars???? - not possible??
\end{itemize}

% TODO add example

\section{Quantifier Elimination}
% TODO say in implementation that we do not eliminate last existential variables, we also delete variables not in support set
In this section we explain how the algorithm for eliminating all quantifiers looks like. This algorihtm is implemented as function \textproc{EliminateAllQuantifiers}, which is used in Algorithm~\ref{alg:general} for eliminating all quantifiers in the final formula (line~\ref{alg:general:elimination}) and can also be used while eliminating quantifiers during transformation to BDDs (line~\ref{turntobdd:eliminate} of Algorithm~\ref{alg:turntobdd}).

\begin{algorithm}
  \caption{Quantifier elimination algorithm}
  \label{alg:allelimination}
  \begin{algorithmic}[1]
    \Function{EliminateAllQuantifiers}{$n$, $\phi_n$}
      \While{$\uprefix{n}$ is not empty}%there is some universal variable $x$ in $\psi$
        \State choose $x$ from $\uprefix{n}$\label{allelimination:choose}
        \State $\phi_n = \forall\text{-expansion}(x,\phi_n)$\Comment{Theorem~\ref{thrm:unExpan}} \label{allelimination:uelim}
        \State remove $x$ from $\prefix{n}$\label{allelimination:uremove}
        \State $Q_{\forall} = \set{x \in \vars{\phi_n} | x \in \uprefix{n'} \text{ for some ancestor } n' \text{ of } n}$\label{allelimination:uset}
        \State $Q_{\exists} = \set{y \in \vars{\phi_n} | y \in \eprefix{n'} \text{ for some ancestor } n' \text{ of } n}$\label{allelimination:eset}
        \State $E = \set{y \in \eprefix{n} | Q_{\forall} \subseteq D_y \text{ and } D_{y'} \subseteq D_y \text{ for all } y \in Q_{\exists}}$\label{allelimination:etoremove}
        \ForAll{$y \in E$}\label{allelimination:eelimforstart}
          \State $\phi_n = \exists\text{-elimination}(y,\phi_n)$\Comment{Theorem~\ref{thrm:exElim}}\label{allelimination:eelim}
          \State remove $y$ from $\prefix{n}$\label{allelimination:eremove}
        \EndFor\label{allelimination:eelimforend}
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:allelimination} shows this function which takes as input a node $n$ and BDD $\psi_n$ representing the matrix of DQBF represented by subtree rooted in $n$. This algorithm is similar to Algorithm~\ref{alg:QE} which is used in HQS. However, while that one was used only for DQBF in PNF, this algorithm works for any subformula. It iteratively eliminates universal variables occuring in prefix $\prefix{n}$ using universal expansion (Theorem~\ref{thrm:unExpan}) and also all possible existential variables using Theorem~\ref{thrm:exElim}. The next universal variable to eliminate is chosen on line~\ref{allelimination:choose} by some heuristic after which we eliminate it from $\psi_n$ and remove it from the quantifier prefix of $n$ (lines~\ref{allelimination:uelim}~and~\ref{allelimination:uremove}). On lines~\ref{allelimination:uset}~and~\ref{allelimination:eset} the sets $Q_{\forall}$ and $Q_{\exists}$ are initialized which are the sets of all universal and existential variables occurring in $\phi_n$. We find them by going trough quantifier prefixes of all ancestors of $n$ (we assume that $n$ is ancestor to itself). We use these sets to compute the set $E$ on line~\ref{allelimination:etoremove} of all existential variables from prefix $\prefix{n}$ which fulfill the conditions set by Theorem~\ref{thrm:exElim}. These variables are those that can be existentially eliminated which we do on lines~\ref{allelimination:eelimforstart}-\ref{allelimination:eelimforend}.

The heuristics we use for choosing the next universal variable to eliminate on line~\ref{allelimination:choose} are these:
\begin{itemize}
    \item The order of universal variables from $\uprefix{n}$ is set at the beginning based on the number of existential variables that depend on them (from lowest to highest). This is done so the number of created existential variables do not grow so fast. %so the created duplicates do not count in, i.e. 
    As an example, let
    \[\forall x_1 \forall x_2 \forall x_3 \exists y_1(x_1, x_2) \exists y_2(x_1,x_2) \exists y_3(x_3) \exists y_4(x_3) \exists y_5 (x_3)\]
    be the quantifier prefix $\prefix{n}$. The order is either $x_1, x_2, x_3$ or $x_2, x_1, x_3$, because for both $x_1$ and $x_2$ only two existential variables $y_1$ and $y_2$ depend on them while for $x_3$ it is three ($y_3$, $y_4$, $y_5$). This heuristic was introduced with HQS~\cite{HQSquantifierElimination}, 
    \item The next heuristic is similar, but the order is not set at the beginning. The next universal variable to eliminate is then the one with the current lowest number of existential variables that depend on it. This means that the existential variables which were created as a copies during universal expansion also count here. For example, take $\prefix{n}$ from the previous example. In this heuristic, at the beginning either $x_1$ or $x_2$ is chosen as in the previous one, because two existential variables depend on them while on $x_3$ three depend. Assume that $x_1$ was chosen and eliminated without any other variable getting removed. The quantifier prefix $\prefix{n}$ is then
    \[\forall x_2 \forall x_3 \exists y_1(x_2) \exists y_2(x_2) \exists y_1'(x_2) \exists y_2'(x_2) \exists y_3(x_3) \exists y_4(x_3) \exists y_5 (x_3)\]
    where $y_1'$ and $y_2'$ were created as copies of $y_1$ and $y_2$ during universal expansion. Now, in the previous heuristic $x_2$ would be chosen. However, here $x_3$ is chosen because it still depends only on three variables, while $x_2$ now depends on four. This heuristic was introduced by Gitina et al.~\cite{HQSsimpleAlg}.
    \item Another heuristic we use is based on the number of variables in the BDDs representing the two conjuncts used for universal expansion in Theorem~\ref{thrm:unExpan}. That is, let $x \in \uprefix{n}$ and $\psi_1^{-x}\substitute{x}{0}$, $\psi_2^{-x}\substitute{x}{1}$
    be the two conjuncts from Theorem~\ref{thrm:unExpan} as if we were doing universal expansion. Because the operation of replacing variables with constants is fast for BDDs, we can create BDDs for these two formulas and check for the amount of variables in both of them, that is the number of variables in the set $\vars{\psi_1^{-x}\substitute{x}{0}} \cup \psi_2^{-x}\substitute{x}{1}$. We can do this for all universal variables and choose the one with the lowest number of variables in this set. If there are multiple such variables, we can also use one of the previous heuristics to choose from them.
    %\item something with creating depency tree, to find existential variables to remove as fast as possible (not sure if possible) --- maybe possible, basically remove those universal vars that will make it possible to remove as much existential vars as possible on the level??? 
\end{itemize}

\chapter{Implementation}
We implemented the algorithm from Chapter~\ref{chap:algorithm} in C\texttt{++} using version 3.0.0 of the CUDD\footnote{\url{https://github.com/ivmai/cudd}} package~\cite{CUDD} for BDD manipulation, version 2.2.0 of the cxxopts\footnote{\url{https://github.com/jarro2783/cxxopts}} library for parsing command-line arguments and preprocessor HQSpre~\cite{HQSpre2}, more specifically the version that was used with HQS with quantifier localisation~\cite{HQSquantifierLocalization}. As was explained in Section~\ref{sec:preprocessing}, HQSpre can extract logical gates from variables in the formula that can be then replaced by them resulting in formula with fewer variables. This results in a formula that does not need to be in PCNF, which most solvers cannot handle. However, as HQS, our solver can work with non-PCNF formulas, stemming from the fact that we represent matrices as either BDDs or quantifier trees. This means that we can use this feature of HQSpre, similarly as it is used for HQS. First we check how many gates can be extracted. If this number is low (we use less than 5), then we run preprocessor normally, without caring whether these gates will get destroyed or not. If there is enough gates, then we run preprocessor normally on a copy of the formula to check if it can solve it. It it cannot, we run the preprocessor with gate preservation setting on. This will ensure that during preprocessing no clause from which these gates are extracted is touched and at the end of preprocessing we can extract these creates while creating BDD or quantifier tree.

%TODO ak nemam odstranovat nic pocas odlokalizovania, tak odlokalizovanie ani nerob

\chapter{Experimental results}
popisat na com testujeme a ze sme pouzili benchexec

povedat ze sme najprv pustili HQSpre (odkaz na sekciu a asi aj znova citovat) bez gate detection, odfiltrovali sme results ktore boli vyriesene HQSpre alebo uz HQSpre prekrocil limity... vysledok tohto sme hodili do iDQ, iProver, dCAQE

pre HQS a moj pouzivame -> ak gate detection zisti ze mame viac ako n gates (v HQS maju teraz 5) tak pustime znova HQSpre ale teraz uz aj s tym ze chranime tieto gates aby sme ich potom mohli pouzit

cas HQSpre bez gate detection zaratavame do vsetkych solvrov, tym silmulujeme to co robi HQSnp???

benchmarks:
\begin{itemize}
    \item PEC - vid \cite{HQSquantifierLocalization} ze co vsetko citovat, su to asi folders Finkbenier, Scholl a Biere v z tej stranky stiahnute co je tam odkaz v tom istom clanku
    \item controller synthesis problems - to iste, folder je ale iba Bloem
    \item ziskane zo SAT - to iste, folder je ale iba Balabanov
    \item BoSy - vid \cite{dCAQE}, nie su ale zverejnene, skusit asi popytat
\end{itemize}
Zrobit asi pre kazdy tento benchmark sekciu a porovnat - grafy, tabulky atd, neviem este. Potom zrobit velky graf kde dam vsetko dohromady mozno, nech vidno spolu ze ake to je. A mozno dat z QBFeval'19, ze povedat ze je to suhrn vybratych benchmarks z tychto (okrem asi BoSy), tak aby nijaky nedominoval a nejak su pekne rozdelene ci co a ukazat na tom ????

Este mozno budem porovnavat navzajom rozne heuristiky pouzite v mojom a potom budem porovnavat najlepsiu???? s ostatnymi????

\chapter{Conclusion}


\begingroup
\setlength{\emergencystretch}{8em}
\printbibliography[heading=bibintoc]
\endgroup

%\chapter{Inserting the index}
%After using the \verb"\makeindex" macro and loading the
%\texttt{makeidx} package that provides additional indexing
%commands, index entries can be created by issuing the \verb"\index"
%command. \index{dummy text|(}It is possible to create ranged index
%entries, which will encompass a span of text.\index{dummy text|)}
%To insert complex typographic material -- such as $\alpha$
%\index{alpha@$\alpha$} or \TeX{} \index{TeX@\TeX} --
%into the index, you need to specify a text string, which will
%determine how the entry will be sorted. It is also possible to
%create hierarchal entries. \index{vehicles!trucks}
%\index{vehicles!speed cars}

%index:
%  \makeatletter\thesis@blocks@clear\makeatother
%  \phantomsection %% Print the index and insert it into the
%  \addcontentsline{toc}{chapter}{\indexname} %% table of contents.
%  \printindex

\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
